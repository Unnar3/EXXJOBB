{
	"auto_complete":
	{
		"selected_items":
		[
			[
				"polys",
				"polys2"
			],
			[
				"poly",
				"polys1"
			],
			[
				"utils",
				"utils::triNorm"
			],
			[
				"Point",
				"PointT"
			],
			[
				"sv",
				"sv_seed_res_"
			],
			[
				"pcl",
				"pcl::ModelCoefficients"
			],
			[
				"coeff",
				"coefficients"
			],
			[
				"coe",
				"coefficients"
			],
			[
				"Eigen",
				"Eigen::Matrix"
			],
			[
				"interse",
				"intersections"
			],
			[
				"tmp",
				"tmp_hull"
			],
			[
				"clou",
				"cloud_mesh_"
			],
			[
				"Test",
				"testCompression"
			],
			[
				"print",
				"printSet"
			],
			[
				"prints",
				"printSetOfSets"
			],
			[
				"sets_",
				"sets_new"
			],
			[
				"data",
				"dataset"
			],
			[
				"inclu",
				"includeWalls"
			],
			[
				"incl",
				"includeWalls"
			],
			[
				"planeF",
				"plane_features"
			],
			[
				"normal",
				"normalInd"
			],
			[
				"norma",
				"normalInd"
			],
			[
				"ve",
				"vector"
			],
			[
				"Color",
				"ColorGradient"
			],
			[
				"get",
				"getValueBetweenTwoFixedColors"
			],
			[
				"EXX",
				"EXX::planeDescriptor"
			],
			[
				"plane",
				"plane_vec"
			],
			[
				"inc",
				"include"
			],
			[
				"PK",
				"PKG2"
			],
			[
				"run",
				"run_depend"
			],
			[
				"ang",
				"angleBetweenVectors"
			],
			[
				"pla",
				"plane_vec"
			],
			[
				"n",
				"normal"
			],
			[
				"wl",
				"widthLengthRatio"
			],
			[
				"hu",
				"hullBoundingBoxRatio"
			],
			[
				"bou",
				"boundingBoxArea"
			],
			[
				"hull",
				"hullDist"
			],
			[
				"bound",
				"boundingBoxDist"
			],
			[
				"mo",
				"momentOfInertia"
			],
			[
				"push",
				"push_back"
			],
			[
				"extrac",
				"extractor"
			],
			[
				"Poi",
				"PointCloudT::Ptr"
			],
			[
				"test",
				"test_cloud"
			],
			[
				"size",
				"size_t"
			],
			[
				"Pont",
				"PointT"
			],
			[
				"moment",
				"moment_of_inertia"
			],
			[
				"catkin",
				"catkin_ws"
			],
			[
				"Vox",
				"VoxelResolution"
			],
			[
				"vo",
				"voxel_cloud"
			],
			[
				"super",
				"super_planes"
			],
			[
				"sup",
				"super_planes"
			],
			[
				"cloud",
				"cloud_f"
			],
			[
				"Poin",
				"PointCloudT::Ptr"
			],
			[
				"st",
				"stdDev"
			],
			[
				"std",
				"stdDev"
			],
			[
				"ret",
				"returnECPlanes"
			],
			[
				"EC",
				"ECMinClusterSize"
			],
			[
				"color",
				"colored_cloud"
			],
			[
				"type",
				"typeid"
			],
			[
				"def",
				"define"
			],
			[
				"save",
				"savePath"
			],
			[
				"exx",
				"exx_common_node"
			],
			[
				"sa",
				"saveMesh"
			],
			[
				"comprs",
				"compression::saveVTK"
			],
			[
				"triang",
				"triangulatePlanes"
			],
			[
				"voxe",
				"voxelGridFilter"
			],
			[
				"gp",
				"gp3_Ksearch_"
			],
			[
				"gp3",
				"gp3_max_nearest_neighbours_"
			],
			[
				"gp3_",
				"gp3_min_angle_"
			],
			[
				"rw",
				"rw_hull_eps_"
			],
			[
				"dis",
				"dist_thresh_"
			],
			[
				"max",
				"max_ite_"
			],
			[
				"sv_s",
				"sv_seed_res_"
			],
			[
				"voxel",
				"voxel_leaf_size_"
			],
			[
				"V",
				"VOXEL_LEAF_SIZE"
			],
			[
				"boundar",
				"boundary_points"
			],
			[
				"new",
				"new_cloud"
			],
			[
				"closes",
				"closestInternal"
			],
			[
				"ge",
				"getCloudSize"
			],
			[
				"set",
				"setInputCloud"
			],
			[
				"name",
				"namespace"
			],
			[
				"ind",
				"ind_loop"
			],
			[
				"Po",
				"PointCloudT"
			],
			[
				"leaf",
				"leaf_size"
			],
			[
				"Plana",
				"PlanarRegT"
			],
			[
				"Plan",
				"PlanarRegT"
			],
			[
				"min",
				"min_inliers_"
			],
			[
				"dist",
				"distance_threshold_"
			],
			[
				"dista",
				"distance_threshold"
			],
			[
				"model",
				"ModelCoeffT"
			],
			[
				"cloud_",
				"cloud_triangle"
			],
			[
				"P",
				"Ptr"
			],
			[
				"triangles",
				"triangles_planes"
			],
			[
				"pol",
				"Polygon"
			],
			[
				"tri",
				"triangles_planes"
			],
			[
				"file",
				"filenames"
			],
			[
				"Me",
				"METAROOM"
			],
			[
				"current",
				"currentPlane"
			],
			[
				"su",
				"super_voxel_planes"
			],
			[
				"number",
				"number_of_planes"
			],
			[
				"inliers",
				"inliers_vec"
			],
			[
				"inlier",
				"inliers_vec"
			],
			[
				"j_",
				"j_nextCheck"
			],
			[
				"j_ne",
				"j_nextCheck"
			],
			[
				"j",
				"j_nextCheck"
			],
			[
				"curre",
				"currentPlane"
			],
			[
				"next",
				"nextCheck"
			],
			[
				"ne",
				"nextCheck"
			],
			[
				"point",
				"pointToLineDistance"
			],
			[
				"CLOUD",
				"cloud_hull_plane"
			]
		]
	},
	"buffers":
	[
		{
			"contents": "#include <exx_compression/compression.h>\n#include <utils/utils.h>\n#include <intersections/intersections.h>\n#include <pcl/filters/voxel_grid.h>\n#include <pcl/filters/extract_indices.h>\n#include <pcl/filters/project_inliers.h>\n#include <pcl/features/normal_3d_omp.h>\n#include <pcl/kdtree/kdtree.h>\n#include <pcl/kdtree/kdtree_flann.h>\n#include <pcl/segmentation/supervoxel_clustering.h>\n#include <pcl/segmentation/sac_segmentation.h>\n#include <pcl/segmentation/extract_clusters.h>\n#include <pcl/surface/concave_hull.h>\n#include <pcl/octree/octree_impl.h>\n#include <math.h>\n\nnamespace EXX{\n\n	void compression::voxelGridFilter(PointCloudT::Ptr cloud, PointCloudT::Ptr out_cloud){\n		pcl::VoxelGrid<PointT> sor;\n		sor.setInputCloud (cloud);\n		sor.setLeafSize (v_leaf_size_, v_leaf_size_, v_leaf_size_);\n		sor.filter (*out_cloud);\n	}\n\n	void compression::superVoxelClustering(vPointCloudT *cloud, vPointCloudT *out_vec, std::vector<densityDescriptor> &dDesc){\n		std::vector<PointCloudTA::Ptr> out_cloud;\n		std::vector<PointCloudT::Ptr>::iterator it = cloud->begin();\n		int i = 0;\n		for (; it != cloud->end(); ++it)\n		{\n			(*out_vec).push_back(  compression::superVoxelClustering_s(*it, dDesc[i++]) );\n		}\n	}\n\n	PointCloudT::Ptr compression::superVoxelClustering_s(PointCloudT::Ptr cloud, densityDescriptor &dDesc){\n\n		pcl::SupervoxelClustering<PointT> super (dDesc.voxel_res, dDesc.seed_res, false);\n		super.setColorImportance (sv_color_imp_);\n		super.setSpatialImportance (sv_spatial_imp_);\n		super.setNormalImportance(0.0f);\n		super.setInputCloud (cloud);\n		std::map <uint32_t, pcl::Supervoxel<PointT>::Ptr > supervoxel_clusters;\n		super.extract (supervoxel_clusters);\n\n		PointCloudTA::Ptr out (new PointCloudTA ());\n		std::map <uint32_t, pcl::Supervoxel<PointT>::Ptr >::iterator it = supervoxel_clusters.begin();\n		for ( ; it != supervoxel_clusters.end() ; ++it ){\n			out->points.push_back( it->second->centroid_ );\n		}\n		return compression::PointRGBAtoRGB(out);\n	} \n\n	void compression::euclideanClusterPlanes(vPointCloudT* cloud, vPointCloudT* out_vec, std::vector<int> *normalIndex){\n		// Loop through all planes\n		int ind = 0;\n		vPointCloudT::iterator ite = cloud->begin();\n		for ( ; ite != cloud->end(); ++ite){\n			// Creating the KdTree object for the search method of the extraction\n			pcl::search::KdTree<PointT>::Ptr tree (new pcl::search::KdTree<PointT>);\n			tree->setInputCloud (*ite);\n\n			std::vector<pcl::PointIndices> cluster_indices;\n			pcl::EuclideanClusterExtraction<PointT> ec;\n			ec.setClusterTolerance (ec_cluster_tolerance_); // 2cm\n			ec.setMinClusterSize (ec_min_cluster_size_);\n			// ec.setMaxClusterSize (25000);\n			ec.setSearchMethod (tree);\n			ec.setInputCloud (*ite);\n			ec.extract (cluster_indices);\n\n			int j = 0;\n			for (std::vector<pcl::PointIndices>::const_iterator it = cluster_indices.begin (); it != cluster_indices.end (); ++it)\n			{\n				PointCloudT::Ptr cloud_cluster (new PointCloudT);\n				for (std::vector<int>::const_iterator pit = it->indices.begin (); pit != it->indices.end (); ++pit)\n					cloud_cluster->points.push_back ((*ite)->points[*pit]); //*\n				cloud_cluster->width = cloud_cluster->points.size ();\n				cloud_cluster->height = 1;\n				cloud_cluster->is_dense = true;\n				(*out_vec).push_back(cloud_cluster);\n				normalIndex->push_back(ind);\n			}\n			ind++;\n		}\n	}\n\n	void compression::extractPlanesRANSAC(PointCloudT::Ptr cloud, planesAndCoeffs *pac)\n	{\n		pcl::SACSegmentationFromNormals<PointT, pcl::Normal> seg;\n		pcl::NormalEstimationOMP<PointT, pcl::Normal> ne;\n		pcl::search::KdTree<PointT>::Ptr tree (new pcl::search::KdTree<PointT> ());\n		pcl::PointIndices::Ptr inliers (new pcl::PointIndices);\n		PointCloudT::Ptr cloud_f (new PointCloudT ());\n		\n		pcl::PointCloud<pcl::Normal>::Ptr cloud_normals (new pcl::PointCloud<pcl::Normal>);\n		pcl::PointCloud<pcl::Normal>::Ptr cloud_n (new pcl::PointCloud<pcl::Normal>);\n		\n		seg.setOptimizeCoefficients (true);\n		seg.setModelType (pcl::SACMODEL_NORMAL_PLANE);\n		seg.setMethodType (pcl::SAC_RANSAC);\n		seg.setMaxIterations (max_ite_);\n		seg.setDistanceThreshold (dist_thresh_);\n		seg.setEpsAngle (2*M_PI);\n		seg.setNormalDistanceWeight (0.2);\n\n		// Estimate point normals\n		ne.setSearchMethod (tree);\n		ne.setInputCloud (cloud);\n		ne.setKSearch (10);\n		ne.compute (*cloud_normals);\n\n		int i=0, nr_points = cloud->points.size ();\n		while (i < max_number_planes_ && cloud->points.size() > 0 && cloud->points.size() > 0.05 * nr_points)\n		{\n		    // Define for each plane we find\n		    ModelCoeffT::Ptr coefficients (new ModelCoeffT);\n		    PointCloudT::Ptr cloud_plane (new PointCloudT ());\n\n		    // Segment the largest planar component from the remaining cloud\n		    seg.setInputCloud (cloud);\n		    seg.setInputNormals(cloud_normals);\n		    seg.segment (*inliers, *coefficients);\n		    \n		    if (inliers->indices.size () == 0)\n		    {\n		        std::cout << \"Could not estimate a planar model for the given dataset.\" << std::endl;\n		        break;\n		    }\n		    if(inliers->indices.size() < min_inliers_){\n		        i++;\n		        break;\n		    }\n\n		    // Extract the planar inliers from the input cloud\n		    pcl::ExtractIndices<PointT> extract;\n		    extract.setInputCloud (cloud);\n		    extract.setIndices (inliers);\n		    extract.setNegative (false);\n		    extract.filter (*cloud_plane);\n\n		    // Remove the planar inliers, extract the rest\n		    extract.setNegative (true);\n		    extract.filter (*cloud_f);\n		    cloud.swap (cloud_f);\n\n		    pcl::ExtractIndices<pcl::Normal> extractN;\n		    extractN.setInputCloud(cloud_normals);\n		    extractN.setIndices (inliers);\n		    extractN.setNegative (true);\n		    extractN.filter(*cloud_n);\n		    cloud_normals.swap(cloud_n);\n\n		    pac->coeff.push_back(coefficients);\n		    pac->cloud.push_back(cloud_plane);\n		    i++;\n		}\n	}\n\n	void compression::projectToPlane(planesAndCoeffs *pac){\n\n		// Create the projection object\n		pcl::ProjectInliers<PointT> proj;\n		proj.setModelType (pcl::SACMODEL_PLANE);\n\n		for (int i = 0; i < pac->cloud.size(); i++){\n		    proj.setInputCloud ( pac->cloud.at(i) );\n		    proj.setModelCoefficients ( pac->coeff.at(i) );\n		    proj.filter ( *(pac->cloud.at(i)) );\n		}\n	}\n\n	void compression::projectToPlaneS(PointCloudT::Ptr cloud, Eigen::Vector4d coeff){\n		pcl::ModelCoefficients::Ptr m_coeff (new pcl::ModelCoefficients ());\n		m_coeff->values.resize (4);\n		m_coeff->values[0] = float(coeff(0));\n		m_coeff->values[1] = float(coeff(1));\n		m_coeff->values[2] = float(coeff(2));\n		m_coeff->values[3] = float(coeff(3));\n		compression::projectToPlaneS(cloud, m_coeff);\n	}	\n\n	void compression::projectToPlaneS(PointCloudT::Ptr cloud, ModelCoeffT::Ptr coeff){\n\n		// Create the projection object\n		pcl::ProjectInliers<PointT> proj;\n		proj.setModelType (pcl::SACMODEL_PLANE);\n	    proj.setInputCloud ( cloud );\n	    proj.setModelCoefficients ( coeff );\n	    proj.filter ( *cloud );\n	}\n\n	void compression::planeToConcaveHull(vPointCloudT *planes, vPointCloudT *hulls){\n\n		vPointCloudT::iterator it = planes->begin();\n		for ( ; it < planes->end(); ++it)\n		{\n			(*hulls).push_back( compression::planeToConcaveHull_s(*it) );\n		}\n	}\n\n	PointCloudT::Ptr compression::planeToConcaveHull_s(PointCloudT::Ptr cloud){\n		\n		pcl::ConcaveHull<PointT> chull;\n		PointCloudT::Ptr cloud_hull (new PointCloudT ());\n		chull.setInputCloud ( cloud );\n        chull.setAlpha ( hull_alpha_ );\n        chull.setKeepInformation ( true );\n        chull.reconstruct (*cloud_hull);\n\n		return cloud_hull;\n	}\n\n	void compression::planeToConvexHull(vPointCloudT &planes, vPointCloudT &hulls, std::vector<double> &area){\n\n		vPointCloudT::iterator it = planes.begin();\n		double are = 0;\n		for ( ; it < planes.end(); ++it)\n		{	\n			PointCloudT::Ptr out (new PointCloudT ());;\n			compression::planeToConvexHull_s(*it, out, are);\n			hulls.push_back( out );\n			area.push_back(are);\n		}\n	}\n\n	void compression::planeToConvexHull_s(const PointCloudT::Ptr cloud, PointCloudT::Ptr out, double &area ){\n		\n		pcl::ConvexHull<PointT> chull;\n		chull.setInputCloud ( cloud );\n        //chull.setAlpha ( hull_alpha_ );\n        chull.setComputeAreaVolume(true);\n        chull.reconstruct (*out);\n        area = chull.getTotalArea();\n	}\n\n	void compression::reumannWitkamLineSimplification(vPointCloudT* hulls, vPointCloudT* s_hulls, std::vector<densityDescriptor> &dDesc){\n\n		vPointCloudT::iterator it = hulls->begin();\n		int i = 0;\n		for ( ; it < hulls->end(); ++it){\n			(*s_hulls).push_back( compression::reumannWitkamLineSimplification_s(*it, dDesc[++i]) );\n		}\n\n	}\n\n	PointCloudT::Ptr compression::reumannWitkamLineSimplification_s(PointCloudT::Ptr cloud, densityDescriptor &dDesc){\n	    \n	    double distToLine, distBetweenPoints;\n	    int j_current, j_next, j_nextCheck, j_last;\n	    PointT current, next, last, nextCheck;\n	    PointCloudT::Ptr cloud_out (new PointCloudT ());\n\n	    pcl::PointIndices::Ptr inliers (new pcl::PointIndices ());\n	    pcl::ExtractIndices<PointT> extract;\n\n        j_current = 0;\n        j_next = j_current + 1;\n        j_last = j_next;\n        j_nextCheck = j_next + 1;\n\n        // Loop through all points in the plane and find redundant points.\n        while(j_nextCheck < cloud->points.size() ){\n            current = cloud->points.at(j_current);\n            next = cloud->points.at(j_next);\n            last = cloud->points.at(j_last);\n            nextCheck = cloud->points.at(j_nextCheck);\n\n            // Check that the point is not to far away current point.\n            distBetweenPoints = compression::distBetweenPoints(current, nextCheck);\n            if (distBetweenPoints > dDesc.rw_max_dist ){\n            	inliers->indices.push_back(j_next);\n            	j_current = j_nextCheck;\n            	j_next = j_current + 1;\n            	j_last = j_next;\n            	j_nextCheck = j_next + 1;\n                continue;\n            }\n\n            // Check that the point is not to far away from the line.\n            distToLine = pointToLineDistance(current, next, nextCheck);\n            if ( distToLine < rw_hull_eps_ ){\n                if ( j_next != j_last ){\n                    inliers->indices.push_back(j_last);\n                }\n                j_last++;\n                j_nextCheck++;\n            } else {\n                inliers->indices.push_back(j_next);\n                j_current = j_nextCheck;\n                j_next = j_current + 1;\n                j_last = j_next;\n                j_nextCheck = j_next + 1;\n            }\n        }\n        // Remove the redundant points.\n        extract.setInputCloud (cloud);\n        extract.setIndices (inliers);\n        extract.setNegative (true);\n        extract.filter (*cloud_out);\n\n        return cloud_out;\n	}\n\n	// TODO: check that both planes belonging to a line are close to the line.\n	void compression::cornerMatching(vPointCloudT &planes, vPointCloudT &hulls, const std::vector<Eigen::Vector4d> &coeff){\n		Eigen::VectorXd line;\n		std::vector<std::vector<Eigen::VectorXd> > lines(planes.size());\n		Eigen::Vector4d point;\n		point(3) = 0;\n		Eigen::Vector4d l_point;\n		l_point(3) = 0;\n		Eigen::Vector4d d_point;\n		d_point(3) = 0;\n		\n		pcl::ProjectInliers<PointT> proj;\n		proj.setModelType (pcl::SACMODEL_LINE);\n		proj.setCopyAllData(true);\n		\n		pcl::ModelCoefficients::Ptr coefficients (new pcl::ModelCoefficients ());\n		coefficients->values.resize(6);\n\n		// Convert pcl::PointT to Eigen::Vector4d\n		auto pointToEigen = [](Eigen::Vector4d& point, PointT& p){\n			point(0) = p.x;\n			point(1) = p.y;\n			point(2) = p.z;\n		};\n\n		// Given bondary points, interior points, line and indexes we project points to the line and \n		// fill in empty space between original point and projected point.\n		auto projectToLine = [&pointToEigen, &proj, &coefficients](PointCloudT::Ptr hull, PointCloudT::Ptr plane, pcl::PointIndices::Ptr inl, Eigen::VectorXd l){			\n			if (inl->indices.size()==0){ return; }\n			std::vector<Eigen::Vector4d> eigenVecs;\n			Eigen::Vector4d eigenVec;\n			eigenVec(3) = 0;\n\n			// Store location of all points that will be projected.\n			for (auto i : inl->indices){\n				pointToEigen(eigenVec, hull->points.at(i));\n				eigenVecs.push_back(eigenVec);\n			}\n\n			// change line equation from eigen to pcl::modelcoefficients.\n			for (size_t i = 0; i < l.size(); ++i){\n				coefficients->values[i] = l(i);\n			}\n\n			// Project the points.\n			PointCloudT::Ptr tmpCloud (new PointCloudT ());\n			proj.setInputCloud(hull);\n			proj.setIndices(inl);\n			proj.setModelCoefficients(coefficients);\n			proj.filter(*hull);\n\n			Eigen::Vector4d projectedPoint;\n			projectedPoint(3) = 0;\n			Eigen::Vector4d vecDiff;\n			int numberPoints = 0;\n			double vecNorm = 0;\n			PointT newPoint;\n			// create new points. \n			for (size_t i = 0; i < inl->indices.size(); ++i){\n				pointToEigen(projectedPoint, hull->points.at(inl->indices.at(i)));\n				vecDiff = eigenVecs[i] - projectedPoint;\n				vecNorm = vecDiff.norm();\n				if ( vecNorm > 0.005 ){ \n					// Create points inbetween if distance is greater than a threshold.\n					for (int j=1; j<numberPoints; ++j){	\n						newPoint.x = eigenVecs[i](0)-vecDiff(0)/numberPoints*j;\n						newPoint.y = eigenVecs[i](1)-vecDiff(1)/numberPoints*j;\n						newPoint.z = eigenVecs[i](2)-vecDiff(2)/numberPoints*j;\n						newPoint.r = hull->points.at(inl->indices.at(i)).r;\n						newPoint.g = hull->points.at(inl->indices.at(i)).g;\n						newPoint.b = hull->points.at(inl->indices.at(i)).b;\n						plane->points.push_back(newPoint);\n					}\n				}\n			}\n		};\n\n		// Find all plane to plane intersections.\n		for (size_t i = 0; i < coeff.size()-1; ++i){\n			for (size_t k = i+1; k < coeff.size(); ++k){\n				if(pcl::planeWithPlaneIntersection( coeff.at(i), coeff.at(k), line, 0.3 )){	\n					lines[i].push_back(line);\n					lines[k].push_back(line);\n				}\n			}\n		}\n\n		float dist;\n		float tmpDist;\n		int distIdx;\n		std::vector<pcl::PointIndices::Ptr> indices;\n		// Project hull points to closest intersection line.\n		for (size_t i = 0; i < hulls.size(); ++i){\n			// Check to see if the plane has any intersections\n			if (lines[i].size()>0){\n				indices.clear();\n				indices.resize(lines[i].size());\n				for (size_t j = 0; j < indices.size(); ++j){\n					indices[j] = pcl::PointIndices::Ptr (new pcl::PointIndices ());\n				}\n				// Go through all boundary points on a plane\n				for (size_t j = 0; j < hulls.at(i)->points.size(); ++j){\n					pointToEigen(point, hulls.at(i)->points.at(j));\n					// for each point calculate dist to all lines and map to closest\n					for (size_t k = 0; k < lines[i].size(); ++k){\n						l_point.head(3) = lines[i][k].head(3);\n						d_point.head(3) = lines[i][k].tail(3);\n						tmpDist = pcl::sqrPointToLineDistance(point.cast<float>(), l_point.cast<float>(), d_point.cast<float>());\n						if (k == 0){\n							dist = tmpDist;\n							distIdx = 0;\n						} else if (tmpDist < dist) {\n							dist = tmpDist;\n							distIdx = k;\n						}\n					}\n					// apply threshold on distance from intersection\n					if(dist < 0.20*0.20){\n						indices[distIdx]->indices.push_back(j);\n					}\n				}\n				// Project the points\n				for (size_t k = 0; k < indices.size(); ++k){\n					projectToLine(hulls.at(i), planes.at(i), indices[k], lines[i][k]);\n				}\n			}\n		}\n	}\n\n	void compression::getPlaneDensity( vPointCloudT &planes, vPointCloudT &hulls,  std::vector<densityDescriptor> &dDesc){\n\n		// check if planes and hulls are same size\n		if ( planes.size() != hulls.size() ){\n			return;\n		}\n\n		// Start by finding area of the planes\n		pcl::MomentOfInertiaEstimation<PointT> feature_extractor;\n        PointT min_point_OBB;\n        PointT max_point_OBB;\n        PointT pos_OBB;\n        Eigen::Matrix3f rot_mat_OBB; \n        densityDescriptor dens;\n\n        for (size_t i = 0; i < hulls.size(); ++i){           \n            feature_extractor.setInputCloud (hulls[i]);\n            feature_extractor.compute ();\n			feature_extractor.getOBB (min_point_OBB, max_point_OBB, pos_OBB, rot_mat_OBB);\n			float x = float( std::abs( max_point_OBB.x - min_point_OBB.x) );\n			float y = float( std::abs( max_point_OBB.y - min_point_OBB.y) );\n			float area = x * y;\n			float max_points = area / ( v_leaf_size_ * v_leaf_size_ ); \n			float pRatio = float(planes[i]->points.size()) / max_points;\n			dens.seed_res = std::min( std::max( std::min( x, y ) / 5.0f * utils::fast_sigmoid(pRatio, 3.0f), v_leaf_size_), sv_seed_res_ );\n			// dens.seed_res = sv_seed_res_;\n			dens.voxel_res = std::min( dens.seed_res, sv_voxel_res_ );\n			dens.rw_max_dist = std::min( dens.seed_res / 2.0f, rw_hull_max_dist_ );\n			dens.gp3_search_rad = std::min( 3.0f * utils::l2_norm(dens.seed_res), gp3_search_rad_ );\n			dDesc.push_back( dens );\n		}\n\n	}\n\n\n	void compression::greedyProjectionTriangulation(PointCloudT::Ptr nonPlanar, vPointCloudT *planes, vPointCloudT *hulls, std::vector<cloudMesh> *cm){\n		PointCloudT::Ptr tmp_cloud (new PointCloudT ());\n		for (size_t i = 0; i < sv_planes_.size(); i++){\n			*tmp_cloud += *planes->at(i);\n			*tmp_cloud += *hulls->at(i);\n		}\n		*tmp_cloud += *nonPlanar;\n		(*cm).push_back( compression::greedyProjectionTriangulation_s( tmp_cloud, gp3_search_rad_ ) );\n	}\n\n	void compression::greedyProjectionTriangulationPlanes(PointCloudT::Ptr nonPlanar, vPointCloudT *planes, vPointCloudT *hulls, std::vector<cloudMesh> *cm, std::vector<densityDescriptor> &dDesc){\n		PointCloudT::Ptr tmp_hull (new PointCloudT ());\n		for (size_t i = 0; i < planes->size(); ++i){\n			PointCloudT::Ptr tmp_cloud (new PointCloudT ());\n			*tmp_hull += *hulls->at(i);\n			*tmp_cloud = *planes->at(i)+*hulls->at(i);\n			(*cm).push_back( compression::greedyProjectionTriangulation_s( tmp_cloud, dDesc[i].gp3_search_rad ));\n		}\n		std::cout << \"finished with planes\" << std::endl;\n		(*cm).push_back( compression::greedyProjectionTriangulation_s( tmp_hull, 0.5f));\n		(*cm).push_back( compression::greedyProjectionTriangulation_s( nonPlanar, utils::l2_norm(v_leaf_size_) * 1.5f ));\n	}\n\n	void compression::greedyProjectionTriangulationPlanes(PointCloudT::Ptr nonPlanar, vPointCloudT &planes, vPointCloudT &hulls, std::vector<cloudMesh> &cm,std::vector<float> &dDesc){\n		for (size_t i = 0; i < planes.size(); ++i){\n			PointCloudT::Ptr tmp_cloud (new PointCloudT ());\n			*tmp_cloud = *planes.at(i)+*hulls.at(i);\n			cm.push_back( compression::greedyProjectionTriangulation_s( tmp_cloud, dDesc[i] ));\n		}\n		if (nonPlanar->points.size() > 0){\n			cm.push_back( compression::greedyProjectionTriangulation_s( nonPlanar, utils::l2_norm(v_leaf_size_) * 1.5f ));\n		}\n	}\n\n	cloudMesh compression::greedyProjectionTriangulation_s(PointCloudT::Ptr cloud, float gp3_rad){\n	    cloudMesh cloud_mesh;\n\n	    // Normal estimation*\n	    pcl::NormalEstimation<PointT, pcl::Normal> n;\n		pcl::PointCloud<pcl::Normal>::Ptr normals (new pcl::PointCloud<pcl::Normal>);\n	    pcl::search::KdTree<PointT>::Ptr tree (new pcl::search::KdTree<PointT>);\n	    pcl::PointCloud<pcl::PointXYZRGBNormal>::Ptr cloud_with_normals (new pcl::PointCloud<pcl::PointXYZRGBNormal>);\n	    pcl::search::KdTree<pcl::PointXYZRGBNormal>::Ptr tree2 (new pcl::search::KdTree<pcl::PointXYZRGBNormal>);\n\n	    // Initialize objects\n	    pcl::GreedyProjectionTriangulation<pcl::PointXYZRGBNormal> gp3;\n\n	    // Set the maximum distance between connected points (maximum edge length)\n	    gp3.setSearchRadius ( gp3_rad );\n\n	    // Set typical values for the parameters\n	    gp3.setMu ( gp3_Mu_ );\n	    gp3.setMaximumNearestNeighbors( gp3_max_nearest_neighbours_ );\n	    gp3.setMaximumSurfaceAngle( gp3_max_surface_angle_ );\n	    gp3.setMinimumAngle( gp3_min_angle_ );\n	    gp3.setMaximumAngle( gp3_max_angle_ ); // 120 degrees\n	    gp3.setNormalConsistency(false);\n\n	    tree->setInputCloud (cloud);\n	    n.setInputCloud (cloud);\n	    n.setSearchMethod (tree);\n	    n.setKSearch ( gp3_Ksearch_ );\n	    n.compute (*normals);\n\n	    // Concatenate the XYZ and normal fields*\n	    pcl::concatenateFields (*cloud, *normals, *cloud_with_normals);\n	    tree2->setInputCloud (cloud_with_normals);\n\n	    // Get result\n	    gp3.setInputCloud (cloud_with_normals);\n	    gp3.setSearchMethod (tree2);\n	    gp3.reconstruct (cloud_mesh.mesh);\n	    cloud_mesh.cloud = cloud;\n	    return cloud_mesh;\n	}\n\n	void compression::improveTriangulation(std::vector<cloudMesh> &cm, vPointCloudT &planes, vPointCloudT &hulls){\n\n		int inlier_cnt = 0;\n		std::vector<int> points;\n		std::vector<int> polys;\n		int max = 0;\n		int min = 0;\n\n		for ( size_t i = 0; i < cm.size()-1; ++i ){\n			inlier_cnt = planes.at(i)->points.size();\n			polys.clear();\n			for ( size_t j = 0; j < cm.at(i).mesh.polygons.size(); ++j ){\n				points.clear();\n				for ( size_t k = 0; k < cm[i].mesh.polygons[j].vertices.size(); ++k ){\n					if ( cm[i].mesh.polygons[j].vertices[k] >= inlier_cnt ){\n						points.push_back(k);\n					}\n				}\n				if ( points.size() > 2 ){\n					max = *std::max_element(points.begin(), points.end()); \n					min = *std::min_element(points.begin(), points.end()); \n					if (max - min < 5){\n						polys.push_back(j);\n					}\n				}\n			}\n			std::sort(polys.begin(), polys.end(), std::greater<int>());\n			for ( auto j : polys ){\n				cm[i].mesh.polygons.erase(cm[i].mesh.polygons.begin() + j);\n			}\n		}\n\n	}\n\n	void compression::improveTriangulation2(std::vector<cloudMesh> &cm, vPointCloudT &planes, vPointCloudT &hulls,  std::vector<std::vector<float> > &normals){\n\n		int inlier_cnt = 0;\n		std::vector<uint32_t> points;\n		std::vector<int> polys;\n		std::vector<PointT> tri;\n		std::vector<float> tmpNorm;\n		int bcount = 0;\n\n		int max = 0;\n		int min = 0;\n\n		// find the normal of first triangle consisting of two boundary points and interior point.\n\n		for ( size_t i = 0; i < cm.size()-1; ++i ){\n			inlier_cnt = planes.at(i)->points.size();\n			polys.clear();\n\n			for ( size_t j = 0; j < cm.at(i).mesh.polygons.size(); ++j ){\n				points.clear();\n				tri.clear();\n				bcount = 0;\n\n				// Count number of boundary points in the triangle				\n				bcount = std::count_if(cm[i].mesh.polygons[j].vertices.begin(), cm[i].mesh.polygons[j].vertices.end(),\n					[inlier_cnt](int number){return (number >= inlier_cnt);});\n\n				if ( bcount > 2 ){ // Three boundary points forming a triangle\n					points = cm[i].mesh.polygons[j].vertices;\n					std::sort(points.begin(), points.end());\n					for(auto k : points){\n						tri.push_back( cm.at(i).cloud->points.at(k) );\n					}\n					tmpNorm = utils::triNorm(tri.at(0), tri.at(1), tri.at(2));\n					if( utils::vecDot(normals[i], tmpNorm) > 0 ){\n						polys.push_back(j);\n					}\n				}\n\n			}\n			std::sort(polys.begin(), polys.end(), std::greater<int>());\n			for ( auto j : polys ){\n				cm[i].mesh.polygons.erase(cm[i].mesh.polygons.begin() + j);	\n			}\n		}\n\n	}\n\n	double compression::pointToLineDistance(PointT current, PointT next, PointT nextCheck){\n		std::vector<float> x0x1;\n		x0x1.push_back(nextCheck.x-current.x);\n		x0x1.push_back(nextCheck.y-current.y);\n		x0x1.push_back(nextCheck.z-current.z);\n\n		std::vector<float> x0x2;\n		x0x2.push_back(nextCheck.x-next.x);\n		x0x2.push_back(nextCheck.y-next.y);\n		x0x2.push_back(nextCheck.z-next.z);\n\n		std::vector<float> x1x2;\n		x1x2.push_back(current.x-next.x);\n		x1x2.push_back(current.y-next.y);\n		x1x2.push_back(current.z-next.z);\n\n		std::vector<float> cross;\n		cross.push_back(x0x1[1]*x0x2[2] - x0x1[2]*x0x2[1]);\n		cross.push_back(x0x1[2]*x0x2[0] - x0x1[0]*x0x2[2]);\n		cross.push_back(x0x1[0]*x0x2[1] - x0x1[1]*x0x2[0]);\n\n		return std::sqrt(cross[0]*cross[0] + cross[1]*cross[1] + cross[2]*cross[2]) / std::sqrt(x1x2[0]*x1x2[0] + x1x2[1]*x1x2[1] + x1x2[2]*x1x2[2]);\n	}\n\n	double compression::distBetweenPoints(PointT a, PointT b){\n		double x = a.x - b.x;\n		double y = a.y - b.y;\n		double z = a.z - b.z;\n\n		return std::sqrt( x*x + y*y + z*z );\n	}\n	\n	PointCloudT::Ptr compression::PointRGBAtoRGB( PointCloudTA::Ptr cloudRGBA ){\n		PointCloudT::Ptr cloud (new PointCloudT ());\n		pcl::copyPointCloud(*cloudRGBA, *cloud);\n		return cloud;\n	}\n\n	void compression::triangulate(){\n		// compression::voxelGridFilter();\n		// compression::extractPlanesRANSAC();\n		// compression::projectToPlane();\n		// compression::planeToConcaveHull();\n		// compression::reumannWitkamLineSimplification();\n		// compression::superVoxelClustering();\n		// compression::greedyProjectionTriangulation();\n	}\n\n	void compression::triangulatePlanes(){\n		// compression::voxelGridFilter()lastd::cout << \"voxel\" << std::endl;\n		// compression::extractPlanesRANSAC();\n		// std::cout << \"ransac\" << std::endl;\n		// compression::projectToPlane();\n		// std::cout << \"project\" << std::endl;\n		// compression::planeToConcaveHull();\n		// std::cout << \"hull\" << std::endl;\n		// compression::reumannWitkamLineSimplification();\n		// std::cout << \"simple hull\" << std::endl;\n		// compression::superVoxelClustering();\n		// std::cout << \"super\" << std::endl;\n		// compression::greedyProjectionTriangulationPlanes();\n		// std::cout << \"triangulation\" << std::endl;\n	}\n}",
			"file": "src/compression.cpp",
			"file_size": 24679,
			"file_write_time": 130771941146680798,
			"settings":
			{
				"buffer_size": 24634,
				"line_ending": "Unix"
			}
		},
		{
			"file": "include/intersections/intersections.hpp",
			"settings":
			{
				"buffer_size": 6233,
				"line_ending": "Unix"
			}
		},
		{
			"file": "CMakeLists.txt",
			"settings":
			{
				"buffer_size": 858,
				"line_ending": "Unix"
			}
		},
		{
			"file": "include/utils/utils.h",
			"settings":
			{
				"buffer_size": 870,
				"line_ending": "Unix"
			}
		},
		{
			"file": "include/utils/utils.hpp",
			"settings":
			{
				"buffer_size": 1449,
				"line_ending": "Unix"
			}
		},
		{
			"file": "include/exx_compression/compression.h",
			"settings":
			{
				"buffer_size": 7044,
				"line_ending": "Unix"
			}
		}
	],
	"build_system": "",
	"build_system_choices":
	[
	],
	"build_varint": "",
	"command_palette":
	{
		"height": 179.0,
		"last_filter": "",
		"selected_items":
		[
			[
				"push",
				"Git: Push"
			],
			[
				"qu",
				"Git: Quick Commit"
			],
			[
				"add",
				"Git: Add..."
			],
			[
				"comm",
				"Git: Quick Commit"
			],
			[
				"git add",
				"Git: Add Current File"
			],
			[
				"qui",
				"Git: Quick Commit"
			],
			[
				"Snippet: ",
				"Snippet: #!/usr/bin/env"
			],
			[
				"pac",
				"PackageResourceViewer: Open Resource"
			],
			[
				"packa",
				"Package Control: Install Package"
			],
			[
				"ad",
				"Git: Add..."
			],
			[
				"commi",
				"Git: Quick Commit"
			],
			[
				"com",
				"Git: Quick Commit"
			],
			[
				"q",
				"Git: Quick Commit"
			],
			[
				"package",
				"Package Control: Install Package"
			],
			[
				"pa",
				"PackageResourceViewer: Extract Package"
			],
			[
				"insta",
				"Package Control: Install Package"
			],
			[
				"gutt",
				"GitGutter: Show Comparing Against"
			],
			[
				"gutter",
				"GitGutter: Compare Against Commit"
			]
		],
		"width": 601.0
	},
	"console":
	{
		"height": 139.0,
		"history":
		[
			"import urllib.request,os,hashlib; h = 'eb2297e1a458f27d836c04bb0cbaf282' + 'd0e7a3098092775ccb37ca9d6b2e4b7d'; pf = 'Package Control.sublime-package'; ipp = sublime.installed_packages_path(); urllib.request.install_opener( urllib.request.build_opener( urllib.request.ProxyHandler()) ); by = urllib.request.urlopen( 'http://packagecontrol.io/' + pf.replace(' ', '%20')).read(); dh = hashlib.sha256(by).hexdigest(); print('Error validating download (got %s instead of %s), please try manual install' % (dh, h)) if dh != h else open(os.path.join( ipp, pf), 'wb' ).write(by)"
		]
	},
	"distraction_free":
	{
		"menu_visible": true,
		"show_minimap": false,
		"show_open_files": false,
		"show_tabs": false,
		"side_bar_visible": false,
		"status_bar_visible": false
	},
	"expanded_folders":
	[
		"/home/unnar/catkin_ws/src/EXXJOBB/compression",
		"/home/unnar/catkin_ws/src/EXXJOBB/compression/include",
		"/home/unnar/catkin_ws/src/EXXJOBB/compression/include/exx_compression",
		"/home/unnar/catkin_ws/src/EXXJOBB/compression/include/intersections",
		"/home/unnar/catkin_ws/src/EXXJOBB/compression/include/plane_features",
		"/home/unnar/catkin_ws/src/EXXJOBB/compression/include/utils",
		"/home/unnar/catkin_ws/src/EXXJOBB/compression/msg",
		"/home/unnar/catkin_ws/src/EXXJOBB/compression/src"
	],
	"file_history":
	[
		"/home/unnar/catkin_ws/src/exx_wall_extraction/CMakeLists.txt",
		"/home/unnar/catkin_ws/src/EXXJOBB/compression/include/intersections/intersections.hpp",
		"/home/unnar/catkin_ws/src/EXXJOBB/compression/include/intersections/intersections.h",
		"/home/unnar/catkin_ws/src/EXXJOBB/compression/msg/planes.msg",
		"/home/unnar/catkin_ws/src/EXXJOBB/compression/include/utils/utils.h",
		"/home/unnar/catkin_ws/src/EXXJOBB/compression/include/utils/utils.cpp",
		"/home/unnar/catkin_ws/src/EXXJOBB/compression/include/utils/utils.hpp",
		"/home/unnar/catkin_ws/src/rosOgre/stderr.log",
		"/home/unnar/.bashrc",
		"/usr/include/opencv2/opencv.hpp",
		"/usr/include/opencv2/calib3d/calib3d.hpp",
		"/usr/include/opencv2/features2d/features2d.hpp",
		"/home/unnar/catkin_ws/src/exx_wall_extraction/stderr.log",
		"/home/unnar/catkin_ws/stderr.log",
		"/home/unnar/bin/catmake.sh",
		"/home/unnar/catkin_ws/build/log.txt",
		"/home/unnar/catkin_ws/build/CMakeFiles/CMakeOutput.log",
		"/home/unnar/catkin_ws/build/CMakeFiles/CMakeError.log",
		"/usr/include/pcl-1.7/pcl/common/common.h",
		"/home/unnar/catkin_ws/src/exx_wall_extraction/moment_of_inertia/moment_of_inertia_estimation.hpp",
		"/home/unnar/catkin_ws/src/exx_wall_extraction/moment_of_inertia/moment_of_inertia_estimation.cpp",
		"/home/unnar/catkin_ws/src/exx_wall_extraction/moment_of_inertia/moment_of_inertia_estimation.h",
		"/home/unnar/catkin_ws/src/exx_wall_extraction/package.xml",
		"/home/unnar/.bash_aliases/bash.aliases",
		"/home/unnar/bin/setupROS.sh",
		"/home/unnar/catkin_ws/src/exx_wall_extraction/parameters/parameters.json",
		"/home/unnar/catkin_ws/src/exx_wall_extraction/include/euclidian_clustering.h",
		"/home/unnar/catkin_ws/src/exx_wall_extraction/parameters/test_plane.yaml",
		"/home/unnar/catkin_ws/src/exx_wall_extraction/include/compression.cpp",
		"/home/unnar/catkin_ws/src/exx_wall_extraction/include/compression.h",
		"/home/unnar/catkin_ws/src/exx_wall_extraction/test_plane.launch",
		"/home/unnar/.config/sublime-text-3/Packages/Alignment/Base File.sublime-settings",
		"/home/unnar/.config/sublime-text-3/Packages/User/Base File.sublime-settings",
		"/home/unnar/.config/sublime-text-3/Packages/User/JSON.sublime-settings",
		"/home/unnar/.bash_aliases",
		"/home/unnar/catkin_ws/src/exx_wall_extraction/.gitignore",
		"/home/unnar/.config/sublime-text-3/Packages/User/cout.sublime-snippet",
		"/home/unnar/.config/sublime-text-3/Packages/Color Scheme - Default/Monokai.tmTheme",
		"/home/unnar/catkin_ws/src/rosOgre/include/BaseApplication.h",
		"/home/unnar/catkin_ws/src/rosOgre/include/PCLfunctions/cloud_generation.h",
		"/home/unnar/catkin_ws/src/rosOgre/src/BaseApplication.cpp",
		"/home/unnar/catkin_ws/src/rosOgre/run_from/resources.cfg",
		"/home/unnar/catkin_ws/src/rosOgre/run_from/plugins.cfg",
		"/home/unnar/catkin_ws/src/rosOgre/run_from/Ogre.log",
		"/home/unnar/catkin_ws/src/rosOgre/include/triangulation/triangulation.h",
		"/home/unnar/catkin_ws/src/rosOgre/include/triangulation/triangulation.cpp",
		"/home/unnar/catkin_ws/src/rosOgre/include/TutorialApplication.h",
		"/home/unnar/catkin_ws/src/rosOgre/dist/media/models/ogrehead.mesh",
		"/home/unnar/catkin_ws/src/rosOgre/dist/media/materials/scripts/Ogre.material",
		"/home/unnar/catkin_ws/src/rosOgre/dist/bin/resources.cfg",
		"/home/unnar/catkin_ws/src/rosOgre/dist/bin/plugins.cfg",
		"/home/unnar/catkin_ws/src/rosOgre/dist/bin/ogre.cfg",
		"/home/unnar/catkin_ws/src/rosOgre/dist/bin/mesh.vtk",
		"/home/unnar/catkin_ws/src/rosOgre/dist/bin/Ogre.log",
		"/home/unnar/catkin_ws/src/rosOgre/package.xml",
		"/home/unnar/catkin_ws/src/rosOgre/README.md",
		"/home/unnar/catkin_ws/src/rosOgre/Ogre.log",
		"/home/unnar/catkin_ws/src/rosOgre/CMakeLists.txt",
		"/home/unnar/catkin_ws/src/exx_wall_extraction/include/compression/plane_concave_hull.h",
		"/home/unnar/catkin_ws/src/exx_wall_extraction/include/compression/cloud_triangulation.h",
		"/home/unnar/catkin_ws/src/exx_wall_extraction/src/plane_compression.cpp",
		"/home/unnar/catkin_ws/src/exx_wall_extraction/include/triangulation/triangulation.cpp",
		"/home/unnar/catkin_ws/src/exx_wall_extraction/include/compression/cloud_filtering.h",
		"/home/unnar/catkin_ws/src/exx_wall_extraction/include/compression/plane_extraction.h",
		"/home/unnar/catkin_ws/src/exx_wall_extraction/include/compression/compress_methods.h",
		"/home/unnar/catkin_ws/src/exx_wall_extraction/src/plane_test.cpp",
		"/home/unnar/catkin_ws/src/exx_wall_extraction/include/compression/plane_compression_node.h",
		"/home/unnar/catkin_ws/src/exx_wall_extraction/include/compression/plane_extraction_node.h",
		"/home/unnar/catkin_ws/src/exx_wall_extraction/include/compression/filtering.h",
		"/home/unnar/catkin_ws/src/exx_wall_extraction/include/exx_plane_extraction/compress_methods.h",
		"/home/unnar/catkin_ws/src/exx_wall_extraction/include/exx_plane_extraction/plane_extraction.h",
		"/home/unnar/.config/sublime-text-3/Packages/Alignment/Default (Linux).sublime-keymap",
		"/home/unnar/.config/sublime-text-3/Packages/Theme - Spacegray/Spacegray Eighties.sublime-theme",
		"/home/unnar/.config/sublime-text-3/Packages/Color Scheme - Default/LAZY.tmTheme",
		"/home/unnar/sublime.tmtheme",
		"/home/unnar/sublime-theme/sublime.sublime-theme",
		"/home/unnar/.config/sublime-text-3/Packages/User/Preferences.sublime-settings",
		"/home/unnar/Desktop/base16-eighties.dark.tmTheme",
		"/home/unnar/.config/sublime-text-3/Packages/Default/Preferences.sublime-settings",
		"/home/unnar/.config/sublime-text-3/Packages/User/GitGutter.sublime-settings",
		"/home/unnar/.config/sublime-text-3/Packages/GitGutter/GitGutter.sublime-settings",
		"/home/unnar/.config/sublime-text-3/Packages/Default/Default (Linux).sublime-keymap",
		"/home/unnar/catkin_ws/src/exx_wall_extraction/src/clouds/mesh.vtk",
		"/media/unnar/Downloads/transmission-postprocess-manual.sh",
		"/usr/share/applications/viewer.desktop",
		"/home/unnar/bash_aliases",
		"/home/unnar/.config/sublime-text-3/Packages/User/Default (Linux).sublime-keymap",
		"/home/unnar/.bashcr",
		"/home/unnar/catkin_ws/src/exx_wall_extraction/.git/config",
		"/home/unnar/catkin_ws/src/beginner_tutorials/src/talker.cpp",
		"/home/unnar/catkin_ws/src/beginner_tutorials/src/listener.cpp",
		"/home/unnar/catkin_ws/src/beginner_tutorials/msg/Num.msg",
		"/home/unnar/catkin_ws/src/beginner_tutorials/package.xml",
		"/home/unnar/catkin_ws/src/beginner_tutorials/CMakeLists.txt"
	],
	"find":
	{
		"height": 42.0
	},
	"find_in_files":
	{
		"height": 118.0,
		"where_history":
		[
			"/home/unnar/catkin_ws/src/rosOgre/include"
		]
	},
	"find_state":
	{
		"case_sensitive": false,
		"find_history":
		[
			"corner",
			"tri",
			"pow",
			"string",
			"1",
			"coeff.at(i)(",
			"coeff.at(i)",
			"PCL_INTERSECTIONS_H_",
			"save",
			"cout",
			"vPlaneDescriptor",
			"\", ",
			"single",
			"cout",
			"primitives",
			"extracted",
			"InputA",
			"findH",
			"findHomo",
			"findH",
			"qt_build",
			"ERROR",
			"10",
			"c_planes",
			"3",
			"front",
			"hullArea",
			"float",
			"pcl::MomentOfInertiaEstimation<PointT> feature_extractor;\n        PointT min_point_OBB;\n        PointT max_point_OBB;\n        PointT position_OBB;\n        Eigen::Matrix3f rotational_matrix_OBB;  \n        std::vector<float> moment_of_inertia;",
			"plane_vec",
			"c_planes",
			"cm ",
			"cm",
			"c_planes",
			"pcl::PointXYZ",
			"g",
			"                (*pit).",
			"(*pit)",
			"MeanK",
			"saveVT",
			"exx_common_node",
			"savePath",
			"super",
			"triangulation",
			"triangles_planes",
			"Ogre::Real ",
			"std::cout",
			"printSelectedPoints",
			"std::cout",
			"base",
			"a_",
			"a",
			"Points[0]",
			"pointIdxNKNSearch",
			"11",
			"99",
			" 2 ",
			"2 ",
			"12",
			"15",
			"87",
			"88",
			"[i",
			"i",
			"ind_loop",
			"(i+1)*(j+1)-1",
			"i*j",
			"ogreManual",
			"SdkTrays",
			"SdkTrays.zip",
			"PROJECT_BINARY_DIR",
			"CMAKE_MODULE_PATH",
			"/OGRE/",
			"CONCAVEHULL_H",
			"CONCAVEHULL",
			"indices",
			"PLANEEXTRACTION_H",
			"PLANEEXTRACTION",
			"PointNCloudT",
			"leaf_size",
			"Eigen",
			" \n",
			"pcl::PointXYZ",
			"pcl::Normal",
			"pcl::PointCloud<PointT>",
			"new pcl::PointCloud<PointT> ",
			" pcl::PointCloud<PointT>",
			"pcl::PointCloud<PointT> ",
			"pcl::PointCloud<PointT>",
			" ());",
			"pcl::PointCloud<PointT> ",
			"pcl::PointCloud<PointT>",
			"57",
			"folder",
			"gitg",
			"number",
			"functio",
			"dasfæadslfkæalsdkf",
			"PointCloudT",
			"cloud",
			"compressed_extracted_planes",
			"compressed_extracted_projected_planes",
			"(*planes)[i]",
			"pcl::PointXYZ",
			"at",
			"x0x1.at",
			".at",
			"at",
			"x0x1.at",
			".at",
			"last",
			"cross",
			"nextCheck",
			"current",
			"PointT",
			"next",
			"PointT next",
			"PointT ",
			"sor",
			"        //sor",
			"//",
			"sor",
			"        //sor",
			"//",
			"pcl::io"
		],
		"highlight": true,
		"in_selection": false,
		"preserve_case": false,
		"regex": false,
		"replace_history":
		[
		],
		"reverse": false,
		"show_context": true,
		"use_buffer2": true,
		"whole_word": false,
		"wrap": true
	},
	"groups":
	[
		{
			"selected": 0,
			"sheets":
			[
				{
					"buffer": 0,
					"file": "src/compression.cpp",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 24634,
						"regions":
						{
						},
						"selection":
						[
							[
								12898,
								12898
							]
						],
						"settings":
						{
							"BracketHighlighterBusy": false,
							"bh_regions":
							[
								"bh_unmatched",
								"bh_unmatched_center",
								"bh_unmatched_open",
								"bh_unmatched_close",
								"bh_unmatched_content",
								"bh_round",
								"bh_round_center",
								"bh_round_open",
								"bh_round_close",
								"bh_round_content",
								"bh_angle",
								"bh_angle_center",
								"bh_angle_open",
								"bh_angle_close",
								"bh_angle_content",
								"bh_single_quote",
								"bh_single_quote_center",
								"bh_single_quote_open",
								"bh_single_quote_close",
								"bh_single_quote_content",
								"bh_curly",
								"bh_curly_center",
								"bh_curly_open",
								"bh_curly_close",
								"bh_curly_content",
								"bh_c_define",
								"bh_c_define_center",
								"bh_c_define_open",
								"bh_c_define_close",
								"bh_c_define_content",
								"bh_regex",
								"bh_regex_center",
								"bh_regex_open",
								"bh_regex_close",
								"bh_regex_content",
								"bh_tag",
								"bh_tag_center",
								"bh_tag_open",
								"bh_tag_close",
								"bh_tag_content",
								"bh_square",
								"bh_square_center",
								"bh_square_open",
								"bh_square_close",
								"bh_square_content",
								"bh_default",
								"bh_default_center",
								"bh_default_open",
								"bh_default_close",
								"bh_default_content",
								"bh_double_quote",
								"bh_double_quote_center",
								"bh_double_quote_open",
								"bh_double_quote_close",
								"bh_double_quote_content"
							],
							"syntax": "Packages/C++/C.tmLanguage",
							"translate_tabs_to_spaces": false
						},
						"translation.x": 0.0,
						"translation.y": 7754.0,
						"zoom_level": 1.0
					},
					"stack_index": 0,
					"type": "text"
				},
				{
					"buffer": 1,
					"file": "include/intersections/intersections.hpp",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 6233,
						"regions":
						{
						},
						"selection":
						[
							[
								4535,
								4535
							]
						],
						"settings":
						{
							"BracketHighlighterBusy": false,
							"bh_regions":
							[
								"bh_c_define",
								"bh_c_define_center",
								"bh_c_define_open",
								"bh_c_define_close",
								"bh_c_define_content",
								"bh_regex",
								"bh_regex_center",
								"bh_regex_open",
								"bh_regex_close",
								"bh_regex_content",
								"bh_single_quote",
								"bh_single_quote_center",
								"bh_single_quote_open",
								"bh_single_quote_close",
								"bh_single_quote_content",
								"bh_curly",
								"bh_curly_center",
								"bh_curly_open",
								"bh_curly_close",
								"bh_curly_content",
								"bh_double_quote",
								"bh_double_quote_center",
								"bh_double_quote_open",
								"bh_double_quote_close",
								"bh_double_quote_content",
								"bh_tag",
								"bh_tag_center",
								"bh_tag_open",
								"bh_tag_close",
								"bh_tag_content",
								"bh_angle",
								"bh_angle_center",
								"bh_angle_open",
								"bh_angle_close",
								"bh_angle_content",
								"bh_square",
								"bh_square_center",
								"bh_square_open",
								"bh_square_close",
								"bh_square_content",
								"bh_default",
								"bh_default_center",
								"bh_default_open",
								"bh_default_close",
								"bh_default_content",
								"bh_unmatched",
								"bh_unmatched_center",
								"bh_unmatched_open",
								"bh_unmatched_close",
								"bh_unmatched_content",
								"bh_round",
								"bh_round_center",
								"bh_round_open",
								"bh_round_close",
								"bh_round_content"
							],
							"syntax": "Packages/C++/C.tmLanguage",
							"tab_size": 2,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
						"translation.y": 2228.0,
						"zoom_level": 1.0
					},
					"stack_index": 1,
					"type": "text"
				},
				{
					"buffer": 2,
					"file": "CMakeLists.txt",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 858,
						"regions":
						{
						},
						"selection":
						[
							[
								344,
								344
							]
						],
						"settings":
						{
							"BracketHighlighterBusy": false,
							"bh_regions":
							[
								"bh_c_define",
								"bh_c_define_center",
								"bh_c_define_open",
								"bh_c_define_close",
								"bh_c_define_content",
								"bh_regex",
								"bh_regex_center",
								"bh_regex_open",
								"bh_regex_close",
								"bh_regex_content",
								"bh_single_quote",
								"bh_single_quote_center",
								"bh_single_quote_open",
								"bh_single_quote_close",
								"bh_single_quote_content",
								"bh_curly",
								"bh_curly_center",
								"bh_curly_open",
								"bh_curly_close",
								"bh_curly_content",
								"bh_double_quote",
								"bh_double_quote_center",
								"bh_double_quote_open",
								"bh_double_quote_close",
								"bh_double_quote_content",
								"bh_tag",
								"bh_tag_center",
								"bh_tag_open",
								"bh_tag_close",
								"bh_tag_content",
								"bh_angle",
								"bh_angle_center",
								"bh_angle_open",
								"bh_angle_close",
								"bh_angle_content",
								"bh_square",
								"bh_square_center",
								"bh_square_open",
								"bh_square_close",
								"bh_square_content",
								"bh_default",
								"bh_default_center",
								"bh_default_open",
								"bh_default_close",
								"bh_default_content",
								"bh_unmatched",
								"bh_unmatched_center",
								"bh_unmatched_open",
								"bh_unmatched_close",
								"bh_unmatched_content",
								"bh_round",
								"bh_round_center",
								"bh_round_open",
								"bh_round_close",
								"bh_round_content"
							],
							"syntax": "Packages/CMakeEditor/CMakeEditor.tmLanguage"
						},
						"translation.x": 0.0,
						"translation.y": 414.0,
						"zoom_level": 1.0
					},
					"stack_index": 2,
					"type": "text"
				},
				{
					"buffer": 3,
					"file": "include/utils/utils.h",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 870,
						"regions":
						{
						},
						"selection":
						[
							[
								423,
								423
							]
						],
						"settings":
						{
							"BracketHighlighterBusy": false,
							"bh_regions":
							[
								"bh_square",
								"bh_square_center",
								"bh_square_open",
								"bh_square_close",
								"bh_square_content",
								"bh_default",
								"bh_default_center",
								"bh_default_open",
								"bh_default_close",
								"bh_default_content",
								"bh_unmatched",
								"bh_unmatched_center",
								"bh_unmatched_open",
								"bh_unmatched_close",
								"bh_unmatched_content",
								"bh_single_quote",
								"bh_single_quote_center",
								"bh_single_quote_open",
								"bh_single_quote_close",
								"bh_single_quote_content",
								"bh_tag",
								"bh_tag_center",
								"bh_tag_open",
								"bh_tag_close",
								"bh_tag_content",
								"bh_double_quote",
								"bh_double_quote_center",
								"bh_double_quote_open",
								"bh_double_quote_close",
								"bh_double_quote_content",
								"bh_regex",
								"bh_regex_center",
								"bh_regex_open",
								"bh_regex_close",
								"bh_regex_content",
								"bh_round",
								"bh_round_center",
								"bh_round_open",
								"bh_round_close",
								"bh_round_content",
								"bh_c_define",
								"bh_c_define_center",
								"bh_c_define_open",
								"bh_c_define_close",
								"bh_c_define_content",
								"bh_curly",
								"bh_curly_center",
								"bh_curly_open",
								"bh_curly_close",
								"bh_curly_content",
								"bh_angle",
								"bh_angle_center",
								"bh_angle_open",
								"bh_angle_close",
								"bh_angle_content"
							],
							"syntax": "Packages/C++/C.tmLanguage",
							"translate_tabs_to_spaces": false
						},
						"translation.x": 0.0,
						"translation.y": 0.0,
						"zoom_level": 1.0
					},
					"stack_index": 4,
					"type": "text"
				},
				{
					"buffer": 4,
					"file": "include/utils/utils.hpp",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 1449,
						"regions":
						{
						},
						"selection":
						[
							[
								891,
								891
							]
						],
						"settings":
						{
							"BracketHighlighterBusy": false,
							"bh_regions":
							[
								"bh_square",
								"bh_square_center",
								"bh_square_open",
								"bh_square_close",
								"bh_square_content",
								"bh_default",
								"bh_default_center",
								"bh_default_open",
								"bh_default_close",
								"bh_default_content",
								"bh_unmatched",
								"bh_unmatched_center",
								"bh_unmatched_open",
								"bh_unmatched_close",
								"bh_unmatched_content",
								"bh_single_quote",
								"bh_single_quote_center",
								"bh_single_quote_open",
								"bh_single_quote_close",
								"bh_single_quote_content",
								"bh_tag",
								"bh_tag_center",
								"bh_tag_open",
								"bh_tag_close",
								"bh_tag_content",
								"bh_double_quote",
								"bh_double_quote_center",
								"bh_double_quote_open",
								"bh_double_quote_close",
								"bh_double_quote_content",
								"bh_regex",
								"bh_regex_center",
								"bh_regex_open",
								"bh_regex_close",
								"bh_regex_content",
								"bh_round",
								"bh_round_center",
								"bh_round_open",
								"bh_round_close",
								"bh_round_content",
								"bh_c_define",
								"bh_c_define_center",
								"bh_c_define_open",
								"bh_c_define_close",
								"bh_c_define_content",
								"bh_curly",
								"bh_curly_center",
								"bh_curly_open",
								"bh_curly_close",
								"bh_curly_content",
								"bh_angle",
								"bh_angle_center",
								"bh_angle_open",
								"bh_angle_close",
								"bh_angle_content"
							],
							"syntax": "Packages/C++/C.tmLanguage",
							"translate_tabs_to_spaces": false
						},
						"translation.x": 0.0,
						"translation.y": 228.0,
						"zoom_level": 1.0
					},
					"stack_index": 3,
					"type": "text"
				},
				{
					"buffer": 5,
					"file": "include/exx_compression/compression.h",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 7044,
						"regions":
						{
						},
						"selection":
						[
							[
								0,
								0
							]
						],
						"settings":
						{
							"BracketHighlighterBusy": false,
							"bh_regions":
							[
								"bh_square",
								"bh_square_center",
								"bh_square_open",
								"bh_square_close",
								"bh_square_content",
								"bh_default",
								"bh_default_center",
								"bh_default_open",
								"bh_default_close",
								"bh_default_content",
								"bh_unmatched",
								"bh_unmatched_center",
								"bh_unmatched_open",
								"bh_unmatched_close",
								"bh_unmatched_content",
								"bh_single_quote",
								"bh_single_quote_center",
								"bh_single_quote_open",
								"bh_single_quote_close",
								"bh_single_quote_content",
								"bh_tag",
								"bh_tag_center",
								"bh_tag_open",
								"bh_tag_close",
								"bh_tag_content",
								"bh_double_quote",
								"bh_double_quote_center",
								"bh_double_quote_open",
								"bh_double_quote_close",
								"bh_double_quote_content",
								"bh_regex",
								"bh_regex_center",
								"bh_regex_open",
								"bh_regex_close",
								"bh_regex_content",
								"bh_round",
								"bh_round_center",
								"bh_round_open",
								"bh_round_close",
								"bh_round_content",
								"bh_c_define",
								"bh_c_define_center",
								"bh_c_define_open",
								"bh_c_define_close",
								"bh_c_define_content",
								"bh_curly",
								"bh_curly_center",
								"bh_curly_open",
								"bh_curly_close",
								"bh_curly_content",
								"bh_angle",
								"bh_angle_center",
								"bh_angle_open",
								"bh_angle_close",
								"bh_angle_content"
							],
							"syntax": "Packages/C++/C.tmLanguage",
							"translate_tabs_to_spaces": false
						},
						"translation.x": 0.0,
						"translation.y": 855.0,
						"zoom_level": 1.0
					},
					"stack_index": 5,
					"type": "text"
				}
			]
		}
	],
	"incremental_find":
	{
		"height": 31.0
	},
	"input":
	{
		"height": 33.0
	},
	"layout":
	{
		"cells":
		[
			[
				0,
				0,
				1,
				1
			]
		],
		"cols":
		[
			0.0,
			1.0
		],
		"rows":
		[
			0.0,
			1.0
		]
	},
	"menu_visible": true,
	"output.exec":
	{
		"height": 258.0
	},
	"output.find_results":
	{
		"height": 0.0
	},
	"pinned_build_system": "",
	"project": "compression.sublime-project",
	"replace":
	{
		"height": 58.0
	},
	"save_all_on_build": true,
	"select_file":
	{
		"height": 0.0,
		"last_filter": "",
		"selected_items":
		[
		],
		"width": 0.0
	},
	"select_project":
	{
		"height": 500.0,
		"last_filter": "",
		"selected_items":
		[
			[
				"",
				"~/catkin_ws/src/EXXJOBB/test/statistic/test_statistic.sublime-project"
			]
		],
		"width": 380.0
	},
	"select_symbol":
	{
		"height": 0.0,
		"last_filter": "",
		"selected_items":
		[
		],
		"width": 0.0
	},
	"selected_group": 0,
	"settings":
	{
	},
	"show_minimap": true,
	"show_open_files": false,
	"show_tabs": true,
	"side_bar_visible": true,
	"side_bar_width": 297.0,
	"status_bar_visible": true,
	"template_settings":
	{
	}
}
