{
	"auto_complete":
	{
		"selected_items":
		[
			[
				"Poi",
				"PointCloudT"
			],
			[
				"pclP",
				"pcl::PointXYZRGB"
			],
			[
				"Poin",
				"PointCloudT"
			],
			[
				"Point",
				"PointCloudT::Ptr"
			],
			[
				"test",
				"test_vec"
			],
			[
				"tes",
				"test_vec"
			],
			[
				"sim",
				"simplifyHulls_"
			],
			[
				"for",
				"for	For Loop"
			],
			[
				"size",
				"size_t"
			],
			[
				"base",
				"baseCloud_"
			],
			[
				"save",
				"savePath"
			],
			[
				"Tut",
				"TutorialApplication::loadBaseCloud"
			],
			[
				"cloud",
				"cloudPath_"
			],
			[
				"load",
				"loadBaseCloud"
			],
			[
				"clo",
				"cloudPath"
			],
			[
				"confi",
				"config_path"
			],
			[
				"Tuto",
				"TutorialApplication"
			],
			[
				"config",
				"configPath"
			],
			[
				"gp3_",
				"gp3_Ksearch_"
			],
			[
				"gp3",
				"gp3_min_angle_"
			],
			[
				"find",
				"find-package	--find-package"
			],
			[
				"voxel",
				"voxel_leaf_size_"
			],
			[
				"voxe",
				"voxel_leaf_size_"
			],
			[
				"V",
				"VOXEL_LEAF_SIZE"
			],
			[
				"bou",
				"boundaryIndexHigh"
			],
			[
				"std",
				"std::endl"
			],
			[
				"boundar",
				"boundary_points"
			],
			[
				"triang",
				"triangulation::angleBetweenVectors"
			],
			[
				"new",
				"new_cloud"
			],
			[
				"closes",
				"closestInternal"
			],
			[
				"super",
				"super_voxel_planes"
			],
			[
				"ge",
				"getCloudSize"
			],
			[
				"set",
				"setInputCloud"
			],
			[
				"name",
				"namespace"
			],
			[
				"ind",
				"ind_loop"
			],
			[
				"Po",
				"PointCloudT"
			],
			[
				"leaf",
				"leaf_size"
			],
			[
				"Plana",
				"PlanarRegT"
			],
			[
				"Plan",
				"PlanarRegT"
			],
			[
				"exx",
				"exx_plane_extraction"
			],
			[
				"min",
				"min_inliers_"
			],
			[
				"dist",
				"distance_threshold_"
			],
			[
				"max",
				"max_iterations_"
			],
			[
				"coe",
				"coeffs"
			],
			[
				"dista",
				"distance_threshold"
			],
			[
				"model",
				"ModelCoeffT"
			],
			[
				"cloud_",
				"cloud_triangle"
			],
			[
				"hull",
				"hulls"
			],
			[
				"P",
				"Ptr"
			],
			[
				"triangles",
				"triangles_planes"
			],
			[
				"pol",
				"Polygon"
			],
			[
				"tri",
				"triangles_planes"
			],
			[
				"file",
				"filenames"
			],
			[
				"Me",
				"METAROOM"
			],
			[
				"current",
				"currentPlane"
			],
			[
				"su",
				"super_voxel_planes"
			],
			[
				"number",
				"number_of_planes"
			],
			[
				"inliers",
				"inliers_vec"
			],
			[
				"inlier",
				"inliers_vec"
			],
			[
				"j_",
				"j_nextCheck"
			],
			[
				"j_ne",
				"j_nextCheck"
			],
			[
				"j",
				"j_nextCheck"
			],
			[
				"curre",
				"currentPlane"
			],
			[
				"next",
				"nextCheck"
			],
			[
				"ne",
				"nextCheck"
			],
			[
				"point",
				"pointToLineDistance"
			],
			[
				"CLOUD",
				"cloud_hull_plane"
			]
		]
	},
	"buffers":
	[
		{
			"file": "src/TutorialApplication.cpp",
			"settings":
			{
				"buffer_size": 8925,
				"line_ending": "Unix"
			}
		},
		{
			"file": "include/TutorialApplication.h",
			"settings":
			{
				"buffer_size": 1651,
				"line_ending": "Unix"
			}
		},
		{
			"file": "include/BaseApplication.h",
			"settings":
			{
				"buffer_size": 3229,
				"line_ending": "Unix"
			}
		},
		{
			"file": "dist/bin/plugins.cfg",
			"settings":
			{
				"buffer_size": 449,
				"line_ending": "Unix"
			}
		},
		{
			"file": "parameters/parameters.yaml",
			"settings":
			{
				"buffer_size": 849,
				"line_ending": "Unix",
				"name": "parameters.yaml"
			}
		},
		{
			"file": "README.md",
			"settings":
			{
				"buffer_size": 564,
				"line_ending": "Unix"
			}
		},
		{
			"contents": "/*\n -----------------------------------------------------------------------------\n This source file is part of OGRE\n (Object-oriented Graphics Rendering Engine)\n For the latest info, see http://www.ogre3d.org/\n \n Copyright (c) 2000-2012 Torus Knot Software Ltd\n \n Permission is hereby granted, free of charge, to any person obtaining a copy\n of this software and associated documentation files (the \"Software\"), to deal\n in the Software without restriction, including without limitation the rights\n to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n copies of the Software, and to permit persons to whom the Software is\n furnished to do so, subject to the following conditions:\n \n The above copyright notice and this permission notice shall be included in\n all copies or substantial portions of the Software.\n \n THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n THE SOFTWARE.\n -----------------------------------------------------------------------------\n */\n#ifndef __SdkTrays_H__\n#define __SdkTrays_H__\n\n#include \"Ogre.h\"\n#include \"OgreFontManager.h\"\n#include \"OgreBorderPanelOverlayElement.h\"\n#include \"OgreTextAreaOverlayElement.h\"\n#include <math.h>\n\n#if OGRE_PLATFORM == OGRE_PLATFORM_ANDROID\n#include \"OgreStringSerialiser.h\"\n#endif\n#include \"OgreTimer.h\"\n\n#if OGRE_COMPILER == OGRE_COMPILER_MSVC\n// TODO - remove this\n#   pragma warning (disable : 4244)\n#endif\n\n#if OGRE_UNICODE_SUPPORT\n	#define DISPLAY_STRING_TO_STRING(DS) (DS.asUTF8())\n#else\n	#define DISPLAY_STRING_TO_STRING(DS) (DS)\n#endif\nnamespace OgreBites\n{\n	enum TrayLocation   // enumerator values for widget tray anchoring locations\n	{\n		TL_TOPLEFT,\n		TL_TOP,\n		TL_TOPRIGHT,\n		TL_LEFT,\n		TL_CENTER,\n		TL_RIGHT,\n		TL_BOTTOMLEFT,\n		TL_BOTTOM,\n		TL_BOTTOMRIGHT,\n		TL_NONE\n	};\n\n	enum ButtonState   // enumerator values for button states\n	{\n		BS_UP,\n		BS_OVER,\n		BS_DOWN\n	};\n\n	// forward widget class declarations\n	class Widget;\n	class Button;\n	class SelectMenu;\n	class Label;\n	class Slider;\n	class CheckBox;\n\n	/*=============================================================================\n	| Listener class for responding to tray events.\n	=============================================================================*/\n	class SdkTrayListener\n    {\n    public:\n\n		virtual ~SdkTrayListener() {}\n		virtual void buttonHit(Button* button) {}\n		virtual void itemSelected(SelectMenu* menu) {}\n		virtual void labelHit(Label* label) {}\n		virtual void sliderMoved(Slider* slider) {}\n		virtual void checkBoxToggled(CheckBox* box) {}\n		virtual void okDialogClosed(const Ogre::DisplayString& message) {}\n		virtual void yesNoDialogClosed(const Ogre::DisplayString& question, bool yesHit) {}\n    };\n\n	/*=============================================================================\n	| Abstract base class for all widgets.\n	=============================================================================*/\n	class Widget\n	{\n	public:\n			\n		Widget()\n		{\n			mTrayLoc = TL_NONE;\n			mElement = 0;\n			mListener = 0;\n		}\n\n		virtual ~Widget() {}\n\n		void cleanup()\n		{\n			if (mElement) nukeOverlayElement(mElement);\n			mElement = 0;\n		}\n\n		/*-----------------------------------------------------------------------------\n		| Static utility method to recursively delete an overlay element plus\n		| all of its children from the system.\n		-----------------------------------------------------------------------------*/\n		static void nukeOverlayElement(Ogre::OverlayElement* element)\n		{\n			Ogre::OverlayContainer* container = dynamic_cast<Ogre::OverlayContainer*>(element);\n			if (container)\n			{\n				std::vector<Ogre::OverlayElement*> toDelete;\n\n				Ogre::OverlayContainer::ChildIterator children = container->getChildIterator();\n				while (children.hasMoreElements())\n				{\n					toDelete.push_back(children.getNext());\n				}\n\n				for (unsigned int i = 0; i < toDelete.size(); i++)\n				{\n					nukeOverlayElement(toDelete[i]);\n				}\n			}\n			if (element)\n			{\n				Ogre::OverlayContainer* parent = element->getParent();\n				if (parent) parent->removeChild(element->getName());\n				Ogre::OverlayManager::getSingleton().destroyOverlayElement(element);\n			}\n		}\n\n		/*-----------------------------------------------------------------------------\n		| Static utility method to check if the cursor is over an overlay element.\n		-----------------------------------------------------------------------------*/\n		static bool isCursorOver(Ogre::OverlayElement* element, const Ogre::Vector2& cursorPos, Ogre::Real voidBorder = 0)\n		{\n			Ogre::OverlayManager& om = Ogre::OverlayManager::getSingleton();\n            Ogre::Real l = element->_getDerivedLeft() * om.getViewportWidth();\n            Ogre::Real t = element->_getDerivedTop() * om.getViewportHeight();\n            Ogre::Real r = l + element->getWidth();\n            Ogre::Real b = t + element->getHeight();\n\n			return (cursorPos.x >= l + voidBorder && cursorPos.x <= r - voidBorder &&\n				cursorPos.y >= t + voidBorder && cursorPos.y <= b - voidBorder);\n		}\n\n		/*-----------------------------------------------------------------------------\n		| Static utility method used to get the cursor's offset from the center\n		| of an overlay element in pixels.\n		-----------------------------------------------------------------------------*/\n		static Ogre::Vector2 cursorOffset(Ogre::OverlayElement* element, const Ogre::Vector2& cursorPos)\n		{\n			Ogre::OverlayManager& om = Ogre::OverlayManager::getSingleton();\n			return Ogre::Vector2(cursorPos.x - (element->_getDerivedLeft() * om.getViewportWidth() + element->getWidth() / 2),\n				cursorPos.y - (element->_getDerivedTop() * om.getViewportHeight() + element->getHeight() / 2));\n		}\n\n		/*-----------------------------------------------------------------------------\n		| Static utility method used to get the width of a caption in a text area.\n		-----------------------------------------------------------------------------*/\n		static Ogre::Real getCaptionWidth(const Ogre::DisplayString& caption, Ogre::TextAreaOverlayElement* area)\n		{\n			Ogre::Font* font = (Ogre::Font*)Ogre::FontManager::getSingleton().getByName(area->getFontName()).getPointer();\n			Ogre::String current = DISPLAY_STRING_TO_STRING(caption);\n			Ogre::Real lineWidth = 0;\n\n			for (unsigned int i = 0; i < current.length(); i++)\n			{\n				// be sure to provide a line width in the text area\n				if (current[i] == ' ')\n				{\n					if (area->getSpaceWidth() != 0) lineWidth += area->getSpaceWidth();\n					else lineWidth += font->getGlyphAspectRatio(' ') * area->getCharHeight();\n				}\n				else if (current[i] == '\\n') break;\n				// use glyph information to calculate line width\n				else lineWidth += font->getGlyphAspectRatio(current[i]) * area->getCharHeight();\n			}\n\n			return (unsigned int)lineWidth;\n		}\n\n		/*-----------------------------------------------------------------------------\n		| Static utility method to cut off a string to fit in a text area.\n		-----------------------------------------------------------------------------*/\n		static void fitCaptionToArea(const Ogre::DisplayString& caption, Ogre::TextAreaOverlayElement* area, Ogre::Real maxWidth)\n		{\n			Ogre::Font* f = (Ogre::Font*)Ogre::FontManager::getSingleton().getByName(area->getFontName()).getPointer();\n			Ogre::String s = DISPLAY_STRING_TO_STRING(caption);\n\n			int nl = s.find('\\n');\n			if (nl != -1) s = s.substr(0, nl);\n\n			Ogre::Real width = 0;\n\n			for (unsigned int i = 0; i < s.length(); i++)\n			{\n				if (s[i] == ' ' && area->getSpaceWidth() != 0) width += area->getSpaceWidth();\n				else width += f->getGlyphAspectRatio(s[i]) * area->getCharHeight();\n				if (width > maxWidth)\n				{\n					s = s.substr(0, i);\n					break;\n				}\n			}\n\n			area->setCaption(s);\n		}\n\n		Ogre::OverlayElement* getOverlayElement()\n		{\n			return mElement;\n		}\n\n		const Ogre::String& getName()\n		{\n			return mElement->getName();\n		}\n\n		TrayLocation getTrayLocation()\n		{\n			return mTrayLoc;\n		}\n\n		void hide()\n		{\n			mElement->hide();\n		}\n\n		void show()\n		{\n			mElement->show();\n		}\n\n		bool isVisible()\n		{\n			return mElement->isVisible();\n		}\n\n		// callbacks\n\n		virtual void _cursorPressed(const Ogre::Vector2& cursorPos) {}\n		virtual void _cursorReleased(const Ogre::Vector2& cursorPos) {}\n		virtual void _cursorMoved(const Ogre::Vector2& cursorPos) {}\n		virtual void _focusLost() {}\n\n		// internal methods used by SdkTrayManager. do not call directly.\n\n		void _assignToTray(TrayLocation trayLoc) { mTrayLoc = trayLoc; }\n		void _assignListener(SdkTrayListener* listener) { mListener = listener; }\n\n	protected:\n\n		Ogre::OverlayElement* mElement;\n		TrayLocation mTrayLoc;\n		SdkTrayListener* mListener;\n	};\n\n	typedef std::vector<Widget*> WidgetList;\n	typedef Ogre::VectorIterator<WidgetList> WidgetIterator;\n\n	/*=============================================================================\n	| Basic button class.\n	=============================================================================*/\n	class Button : public Widget\n	{\n	public:\n\n		// Do not instantiate any widgets directly. Use SdkTrayManager.\n		Button(const Ogre::String& name, const Ogre::DisplayString& caption, Ogre::Real width)\n		{\n			mElement = Ogre::OverlayManager::getSingleton().createOverlayElementFromTemplate(\"SdkTrays/Button\", \"BorderPanel\", name);\n			mBP = (Ogre::BorderPanelOverlayElement*)mElement;\n			mTextArea = (Ogre::TextAreaOverlayElement*)mBP->getChild(mBP->getName() + \"/ButtonCaption\");\n#if OGRE_PLATFORM == OGRE_PLATFORM_APPLE_IOS\n            mTextArea->setCharHeight(mTextArea->getCharHeight() - 3);\n#endif\n			mTextArea->setTop(-(mTextArea->getCharHeight() / 2));\n\n			if (width > 0)\n			{\n				mElement->setWidth(width);\n				mFitToContents = false;\n			}\n			else mFitToContents = true;\n\n			setCaption(caption);\n			mState = BS_UP;\n		}\n\n		virtual ~Button() {}\n\n		const Ogre::DisplayString& getCaption()\n		{\n			return mTextArea->getCaption();\n		}\n\n		void setCaption(const Ogre::DisplayString& caption)\n		{\n			mTextArea->setCaption(caption);\n			if (mFitToContents) mElement->setWidth(getCaptionWidth(caption, mTextArea) + mElement->getHeight() - 12);\n		}\n\n		const ButtonState& getState() { return mState; }\n\n		void _cursorPressed(const Ogre::Vector2& cursorPos)\n		{\n			if (isCursorOver(mElement, cursorPos, 4)) setState(BS_DOWN);\n		}\n\n		void _cursorReleased(const Ogre::Vector2& cursorPos)\n		{\n			if (mState == BS_DOWN)\n			{\n				setState(BS_OVER);\n				if (mListener) mListener->buttonHit(this);\n			}\n		}\n\n		void _cursorMoved(const Ogre::Vector2& cursorPos)\n		{\n			if (isCursorOver(mElement, cursorPos, 4))\n			{\n				if (mState == BS_UP) setState(BS_OVER);\n			}\n			else\n			{\n				if (mState != BS_UP) setState(BS_UP);\n			}\n		}\n\n		void _focusLost()\n		{\n			setState(BS_UP);   // reset button if cursor was lost\n		}\n\n	protected:\n\n		void setState(const ButtonState& bs)\n		{\n			if (bs == BS_OVER)\n			{\n				mBP->setBorderMaterialName(\"SdkTrays/Button/Over\");\n				mBP->setMaterialName(\"SdkTrays/Button/Over\");\n			}\n			else if (bs == BS_UP)\n			{\n				mBP->setBorderMaterialName(\"SdkTrays/Button/Up\");\n				mBP->setMaterialName(\"SdkTrays/Button/Up\");\n			}\n			else\n			{\n				mBP->setBorderMaterialName(\"SdkTrays/Button/Down\");\n				mBP->setMaterialName(\"SdkTrays/Button/Down\");\n			}\n\n			mState = bs;\n		}\n\n		ButtonState mState;\n		Ogre::BorderPanelOverlayElement* mBP;\n		Ogre::TextAreaOverlayElement* mTextArea;\n		bool mFitToContents;\n	};  \n\n	/*=============================================================================\n	| Scrollable text box widget.\n	=============================================================================*/\n	class TextBox : public Widget\n	{\n	public:\n\n		// Do not instantiate any widgets directly. Use SdkTrayManager.\n		TextBox(const Ogre::String& name, const Ogre::DisplayString& caption, Ogre::Real width, Ogre::Real height)\n		{\n			mElement = Ogre::OverlayManager::getSingleton().createOverlayElementFromTemplate(\"SdkTrays/TextBox\", \"BorderPanel\", name);\n			mElement->setWidth(width);\n			mElement->setHeight(height);\n			Ogre::OverlayContainer* container = (Ogre::OverlayContainer*)mElement;\n			mTextArea = (Ogre::TextAreaOverlayElement*)container->getChild(getName() + \"/TextBoxText\");\n			mCaptionBar = (Ogre::BorderPanelOverlayElement*)container->getChild(getName() + \"/TextBoxCaptionBar\");\n			mCaptionBar->setWidth(width - 4);\n			mCaptionTextArea = (Ogre::TextAreaOverlayElement*)mCaptionBar->getChild(mCaptionBar->getName() + \"/TextBoxCaption\");\n			setCaption(caption);\n			mScrollTrack = (Ogre::BorderPanelOverlayElement*)container->getChild(getName() + \"/TextBoxScrollTrack\");\n			mScrollHandle = (Ogre::PanelOverlayElement*)mScrollTrack->getChild(mScrollTrack->getName() + \"/TextBoxScrollHandle\");\n			mScrollHandle->hide();\n			mDragging = false;\n			mScrollPercentage = 0;\n			mStartingLine = 0;\n			mPadding = 15;\n			mText = \"\";\n#if OGRE_PLATFORM == OGRE_PLATFORM_APPLE_IOS\n            mTextArea->setCharHeight(mTextArea->getCharHeight() - 3);\n            mCaptionTextArea->setCharHeight(mCaptionTextArea->getCharHeight() - 3);\n#endif\n			refitContents();\n		}\n\n		void setPadding(Ogre::Real padding)\n		{\n			mPadding = padding;\n			refitContents();\n		}\n\n		Ogre::Real getPadding()\n		{\n			return mPadding;\n		}\n\n		const Ogre::DisplayString& getCaption()\n		{\n			return mCaptionTextArea->getCaption();\n		}\n\n		void setCaption(const Ogre::DisplayString& caption)\n		{\n			mCaptionTextArea->setCaption(caption);\n		}\n\n		const Ogre::DisplayString& getText()\n		{\n			return mText;\n		}\n\n		/*-----------------------------------------------------------------------------\n		| Sets text box content. Most of this method is for wordwrap.\n		-----------------------------------------------------------------------------*/\n		void setText(const Ogre::DisplayString& text)\n		{\n			mText = text;\n			mLines.clear();\n\n			Ogre::Font* font = (Ogre::Font*)Ogre::FontManager::getSingleton().getByName(mTextArea->getFontName()).getPointer();\n            \n			Ogre::String current = DISPLAY_STRING_TO_STRING(text);\n			bool firstWord = true;\n			unsigned int lastSpace = 0;\n			unsigned int lineBegin = 0;\n			Ogre::Real lineWidth = 0;\n			Ogre::Real rightBoundary = mElement->getWidth() - 2 * mPadding + mScrollTrack->getLeft() + 10;\n\n			for (unsigned int i = 0; i < current.length(); i++)\n			{\n				if (current[i] == ' ')\n				{\n					if (mTextArea->getSpaceWidth() != 0) lineWidth += mTextArea->getSpaceWidth();\n					else lineWidth += font->getGlyphAspectRatio(' ') * mTextArea->getCharHeight();\n					firstWord = false;\n					lastSpace = i;\n				}\n				else if (current[i] == '\\n')\n				{\n					firstWord = true;\n					lineWidth = 0;\n					mLines.push_back(current.substr(lineBegin, i - lineBegin));\n					lineBegin = i + 1;\n				}\n				else\n				{\n					// use glyph information to calculate line width\n					lineWidth += font->getGlyphAspectRatio(current[i]) * mTextArea->getCharHeight();\n					if (lineWidth > rightBoundary)\n					{\n						if (firstWord)\n						{\n							current.insert(i, \"\\n\");\n							i = i - 1;\n						}\n						else\n						{\n							current[lastSpace] = '\\n';\n							i = lastSpace - 1;\n						}\n					}\n				}\n			}\n\n			mLines.push_back(current.substr(lineBegin));\n\n			unsigned int maxLines = getHeightInLines();\n\n			if (mLines.size() > maxLines)     // if too much text, filter based on scroll percentage\n			{\n				mScrollHandle->show();\n				filterLines();\n			}\n			else       // otherwise just show all the text\n			{\n				mTextArea->setCaption(current);\n				mScrollHandle->hide();\n				mScrollPercentage = 0;\n				mScrollHandle->setTop(0);\n			}\n		}\n\n		/*-----------------------------------------------------------------------------\n		| Sets text box content horizontal alignment.\n		-----------------------------------------------------------------------------*/\n		void setTextAlignment(Ogre::TextAreaOverlayElement::Alignment ta)\n		{\n			if (ta == Ogre::TextAreaOverlayElement::Left) mTextArea->setHorizontalAlignment(Ogre::GHA_LEFT);\n			else if (ta == Ogre::TextAreaOverlayElement::Center) mTextArea->setHorizontalAlignment(Ogre::GHA_CENTER);\n			else mTextArea->setHorizontalAlignment(Ogre::GHA_RIGHT);\n			refitContents();\n		}\n\n		void clearText()\n		{\n			setText(\"\");\n		}\n\n		void appendText(const Ogre::DisplayString& text)\n		{\n			setText(getText() + text);\n		}\n\n		/*-----------------------------------------------------------------------------\n		| Makes adjustments based on new padding, size, or alignment info.\n		-----------------------------------------------------------------------------*/\n		void refitContents()\n		{\n			mScrollTrack->setHeight(mElement->getHeight() - mCaptionBar->getHeight() - 20);\n			mScrollTrack->setTop(mCaptionBar->getHeight() + 10);\n\n			mTextArea->setTop(mCaptionBar->getHeight() + mPadding - 5);\n			if (mTextArea->getHorizontalAlignment() == Ogre::GHA_RIGHT) mTextArea->setLeft(-mPadding + mScrollTrack->getLeft());\n			else if (mTextArea->getHorizontalAlignment() == Ogre::GHA_LEFT) mTextArea->setLeft(mPadding);\n			else mTextArea->setLeft(mScrollTrack->getLeft() / 2);\n\n			setText(getText());\n		}\n\n		/*-----------------------------------------------------------------------------\n		| Sets how far scrolled down the text is as a percentage.\n		-----------------------------------------------------------------------------*/\n		void setScrollPercentage(Ogre::Real percentage)\n		{\n			mScrollPercentage = Ogre::Math::Clamp<Ogre::Real>(percentage, 0, 1);\n			mScrollHandle->setTop((int)(percentage * (mScrollTrack->getHeight() - mScrollHandle->getHeight())));\n			filterLines();\n		}\n\n		/*-----------------------------------------------------------------------------\n		| Gets how far scrolled down the text is as a percentage.\n		-----------------------------------------------------------------------------*/\n		Ogre::Real getScrollPercentage()\n		{\n			return mScrollPercentage;\n		}\n\n		/*-----------------------------------------------------------------------------\n		| Gets how many lines of text can fit in this window.\n		-----------------------------------------------------------------------------*/\n		unsigned int getHeightInLines()\n		{\n			return (unsigned int) ((mElement->getHeight() - 2 * mPadding - mCaptionBar->getHeight() + 5) / mTextArea->getCharHeight());\n		}\n\n		void _cursorPressed(const Ogre::Vector2& cursorPos)\n		{\n			if (!mScrollHandle->isVisible()) return;   // don't care about clicks if text not scrollable\n\n			Ogre::Vector2 co = Widget::cursorOffset(mScrollHandle, cursorPos);\n\n			if (co.squaredLength() <= 81)\n			{\n				mDragging = true;\n				mDragOffset = co.y;\n			}\n			else if (Widget::isCursorOver(mScrollTrack, cursorPos))\n			{\n				Ogre::Real newTop = mScrollHandle->getTop() + co.y;\n				Ogre::Real lowerBoundary = mScrollTrack->getHeight() - mScrollHandle->getHeight();\n				mScrollHandle->setTop(Ogre::Math::Clamp<int>((int)newTop, 0, (int)lowerBoundary));\n\n				// update text area contents based on new scroll percentage\n				mScrollPercentage = Ogre::Math::Clamp<Ogre::Real>(newTop / lowerBoundary, 0, 1);\n				filterLines();\n			}\n		}\n\n		void _cursorReleased(const Ogre::Vector2& cursorPos)\n		{\n			mDragging = false;\n		}\n\n		void _cursorMoved(const Ogre::Vector2& cursorPos)\n		{\n			if (mDragging)\n			{\n				Ogre::Vector2 co = Widget::cursorOffset(mScrollHandle, cursorPos);\n				Ogre::Real newTop = mScrollHandle->getTop() + co.y - mDragOffset;\n				Ogre::Real lowerBoundary = mScrollTrack->getHeight() - mScrollHandle->getHeight();\n				mScrollHandle->setTop(Ogre::Math::Clamp<int>((int)newTop, 0, (int)lowerBoundary));\n\n				// update text area contents based on new scroll percentage\n				mScrollPercentage = Ogre::Math::Clamp<Ogre::Real>(newTop / lowerBoundary, 0, 1);\n				filterLines();\n			}\n		}\n\n		void _focusLost()\n		{\n			mDragging = false;  // stop dragging if cursor was lost\n		}\n\n	protected:\n\n		/*-----------------------------------------------------------------------------\n		| Decides which lines to show.\n		-----------------------------------------------------------------------------*/\n		void filterLines()\n		{\n			Ogre::String shown = \"\";\n			unsigned int maxLines = getHeightInLines();\n			unsigned int newStart = (unsigned int) (mScrollPercentage * (mLines.size() - maxLines) + 0.5);\n\n			mStartingLine = newStart;\n\n			for (unsigned int i = 0; i < maxLines; i++)\n			{\n				shown += mLines[mStartingLine + i] + \"\\n\";\n			}\n\n			mTextArea->setCaption(shown);    // show just the filtered lines\n		}\n\n		Ogre::TextAreaOverlayElement* mTextArea;\n		Ogre::BorderPanelOverlayElement* mCaptionBar;\n		Ogre::TextAreaOverlayElement* mCaptionTextArea;\n		Ogre::BorderPanelOverlayElement* mScrollTrack;\n		Ogre::PanelOverlayElement* mScrollHandle;\n		Ogre::DisplayString mText;\n		Ogre::StringVector mLines;\n		Ogre::Real mPadding;\n		bool mDragging;\n		Ogre::Real mScrollPercentage;\n		Ogre::Real mDragOffset;\n		unsigned int mStartingLine;\n	};\n\n	/*=============================================================================\n	| Basic selection menu widget.\n	=============================================================================*/\n	class SelectMenu : public Widget\n	{\n	public:\n\n		// Do not instantiate any widgets directly. Use SdkTrayManager.\n		SelectMenu(const Ogre::String& name, const Ogre::DisplayString& caption, Ogre::Real width,\n			Ogre::Real boxWidth, unsigned int maxItemsShown)\n			: mHighlightIndex(0)\n			, mDisplayIndex(0)\n			, mDragOffset(0.0f)\n		{\n			mSelectionIndex = -1;\n			mFitToContents = false;\n			mCursorOver = false;\n			mExpanded = false;\n			mDragging = false;\n			mMaxItemsShown = maxItemsShown;\n			mItemsShown = 0;\n			mElement = (Ogre::BorderPanelOverlayElement*)Ogre::OverlayManager::getSingleton().createOverlayElementFromTemplate\n				(\"SdkTrays/SelectMenu\", \"BorderPanel\", name);\n			mTextArea = (Ogre::TextAreaOverlayElement*)((Ogre::OverlayContainer*)mElement)->getChild(name + \"/MenuCaption\");\n			mSmallBox = (Ogre::BorderPanelOverlayElement*)((Ogre::OverlayContainer*)mElement)->getChild(name + \"/MenuSmallBox\");\n			mSmallBox->setWidth(width - 10);\n			mSmallTextArea = (Ogre::TextAreaOverlayElement*)mSmallBox->getChild(name + \"/MenuSmallBox/MenuSmallText\");\n			mElement->setWidth(width);\n#if OGRE_PLATFORM == OGRE_PLATFORM_APPLE_IOS\n            mTextArea->setCharHeight(mTextArea->getCharHeight() - 3);\n            mSmallTextArea->setCharHeight(mSmallTextArea->getCharHeight() - 3);\n#endif\n            \n			if (boxWidth > 0)  // long style\n			{\n				if (width <= 0) mFitToContents = true;\n				mSmallBox->setWidth(boxWidth);\n				mSmallBox->setTop(2);\n				mSmallBox->setLeft(width - boxWidth - 5);\n				mElement->setHeight(mSmallBox->getHeight() + 4);\n				mTextArea->setHorizontalAlignment(Ogre::GHA_LEFT);\n				mTextArea->setAlignment(Ogre::TextAreaOverlayElement::Left);\n				mTextArea->setLeft(12);\n				mTextArea->setTop(10);\n			}\n						\n			mExpandedBox = (Ogre::BorderPanelOverlayElement*)((Ogre::OverlayContainer*)mElement)->getChild(name + \"/MenuExpandedBox\");\n			mExpandedBox->setWidth(mSmallBox->getWidth() + 10);\n			mExpandedBox->hide();\n			mScrollTrack = (Ogre::BorderPanelOverlayElement*)mExpandedBox->getChild(mExpandedBox->getName() + \"/MenuScrollTrack\");\n			mScrollHandle = (Ogre::PanelOverlayElement*)mScrollTrack->getChild(mScrollTrack->getName() + \"/MenuScrollHandle\");\n\n			setCaption(caption);\n		}\n\n		bool isExpanded()\n		{\n			return mExpanded;\n		}\n\n		const Ogre::DisplayString& getCaption()\n		{\n			return mTextArea->getCaption();\n		}\n\n		void setCaption(const Ogre::DisplayString& caption)\n		{\n			mTextArea->setCaption(caption);\n			if (mFitToContents)\n			{\n				mElement->setWidth(getCaptionWidth(caption, mTextArea) + mSmallBox->getWidth() + 23);\n				mSmallBox->setLeft(mElement->getWidth() - mSmallBox->getWidth() - 5);\n			}\n		}\n\n		const Ogre::StringVector& getItems()\n		{\n			return mItems;\n		}\n\n		unsigned int getNumItems()\n		{\n			return mItems.size();\n		}\n\n		void setItems(const Ogre::StringVector& items)\n		{\n			mItems = items;\n			mSelectionIndex = -1;\n\n			for (unsigned int i = 0; i < mItemElements.size(); i++)   // destroy all the item elements\n			{\n				nukeOverlayElement(mItemElements[i]);\n			}\n			mItemElements.clear();\n\n			mItemsShown = std::max<int>(2, std::min<int>(mMaxItemsShown, mItems.size()));\n\n			for (unsigned int i = 0; i < mItemsShown; i++)   // create all the item elements\n			{\n				Ogre::BorderPanelOverlayElement* e =\n					(Ogre::BorderPanelOverlayElement*)Ogre::OverlayManager::getSingleton().createOverlayElementFromTemplate\n					(\"SdkTrays/SelectMenuItem\", \"BorderPanel\",\n					mExpandedBox->getName() + \"/Item\" + Ogre::StringConverter::toString(i + 1));\n\n				e->setTop(6 + i * (mSmallBox->getHeight() - 8));\n				e->setWidth(mExpandedBox->getWidth() - 32);\n\n				mExpandedBox->addChild(e);\n				mItemElements.push_back(e);\n			}\n\n			if (!items.empty()) selectItem(0, false);\n			else mSmallTextArea->setCaption(\"\");\n		}\n\n		void addItem(const Ogre::DisplayString& item)\n		{\n			mItems.push_back(item);\n			setItems(mItems);\n		}\n\n		void removeItem(const Ogre::DisplayString& item)\n		{\n			Ogre::StringVector::iterator it;\n\n			for (it = mItems.begin(); it != mItems.end(); it++)\n			{\n				if (item == *it) break;\n			}\n\n			if (it != mItems.end())\n			{\n				mItems.erase(it);\n				if (mItems.size() < mItemsShown)\n				{\n					mItemsShown = mItems.size();\n					nukeOverlayElement(mItemElements.back());\n					mItemElements.pop_back();\n				}\n			}\n			else \n			{\n				Ogre::String desc = \"Menu \\\"\" + getName() + \"\\\" contains no item \\\"\" + item + \"\\\".\";\n				OGRE_EXCEPT(Ogre::Exception::ERR_ITEM_NOT_FOUND, desc, \"SelectMenu::removeItem\");\n			}\n		}\n\n		void removeItem(unsigned int index)\n		{\n			Ogre::StringVector::iterator it;\n			unsigned int i = 0;\n\n			for (it = mItems.begin(); it != mItems.end(); it++)\n			{\n				if (i == index) break;\n				i++;\n			}\n\n			if (it != mItems.end())\n			{\n				mItems.erase(it);\n				if (mItems.size() < mItemsShown)\n				{\n					mItemsShown = mItems.size();\n					nukeOverlayElement(mItemElements.back());\n					mItemElements.pop_back();\n				}\n			}\n			else \n			{\n				Ogre::String desc = \"Menu \\\"\" + getName() + \"\\\" contains no item at position \" +\n					Ogre::StringConverter::toString(index) + \".\";\n				OGRE_EXCEPT(Ogre::Exception::ERR_ITEM_NOT_FOUND, desc, \"SelectMenu::removeItem\");\n			}\n		}\n\n		void clearItems()\n		{\n			mItems.clear();\n			mSelectionIndex = -1;\n			mSmallTextArea->setCaption(\"\");\n		}\n\n		void selectItem(unsigned int index, bool notifyListener = true)\n		{\n			if (index >= mItems.size())\n			{\n				Ogre::String desc = \"Menu \\\"\" + getName() + \"\\\" contains no item at position \" +\n					Ogre::StringConverter::toString(index) + \".\";\n				OGRE_EXCEPT(Ogre::Exception::ERR_ITEM_NOT_FOUND, desc, \"SelectMenu::selectItem\");\n			}\n\n			mSelectionIndex = index;\n			fitCaptionToArea(mItems[index], mSmallTextArea, mSmallBox->getWidth() - mSmallTextArea->getLeft() * 2);\n\n			if (mListener && notifyListener) mListener->itemSelected(this);\n		}\n\n		void selectItem(const Ogre::DisplayString& item, bool notifyListener = true)\n		{\n			for (unsigned int i = 0; i < mItems.size(); i++)\n			{\n				if (item == mItems[i])\n				{\n					selectItem(i, notifyListener);\n					return;\n				}\n			}\n\n			Ogre::String desc = \"Menu \\\"\" + getName() + \"\\\" contains no item \\\"\" + item + \"\\\".\";\n			OGRE_EXCEPT(Ogre::Exception::ERR_ITEM_NOT_FOUND, desc, \"SelectMenu::selectItem\");\n		}\n\n		Ogre::DisplayString getSelectedItem()\n		{\n			if (mSelectionIndex == -1)\n			{\n				Ogre::String desc = \"Menu \\\"\" + getName() + \"\\\" has no item selected.\";\n				OGRE_EXCEPT(Ogre::Exception::ERR_ITEM_NOT_FOUND, desc, \"SelectMenu::getSelectedItem\");\n				return \"\";\n			}\n			else return mItems[mSelectionIndex];\n		}\n\n		int getSelectionIndex()\n		{\n			return mSelectionIndex;\n		}\n\n		void _cursorPressed(const Ogre::Vector2& cursorPos)\n		{\n			Ogre::OverlayManager& om = Ogre::OverlayManager::getSingleton();\n\n			if (mExpanded)\n			{\n				if (mScrollHandle->isVisible())   // check for scrolling\n				{\n					Ogre::Vector2 co = Widget::cursorOffset(mScrollHandle, cursorPos);\n\n					if (co.squaredLength() <= 81)\n					{\n						mDragging = true;\n						mDragOffset = co.y;\n						return;\n					}\n					else if (Widget::isCursorOver(mScrollTrack, cursorPos))\n					{\n						Ogre::Real newTop = mScrollHandle->getTop() + co.y;\n						Ogre::Real lowerBoundary = mScrollTrack->getHeight() - mScrollHandle->getHeight();\n						mScrollHandle->setTop(Ogre::Math::Clamp<int>((int)newTop, 0, (int)lowerBoundary));\n\n						Ogre::Real scrollPercentage = Ogre::Math::Clamp<Ogre::Real>(newTop / lowerBoundary, 0, 1);\n						setDisplayIndex((unsigned int)(scrollPercentage * (mItems.size() - mItemElements.size()) + 0.5));\n						return;\n					}\n				}\n\n				if (!isCursorOver(mExpandedBox, cursorPos, 3)) retract();\n				else\n				{\n					Ogre::Real l = mItemElements.front()->_getDerivedLeft() * om.getViewportWidth() + 5;\n					Ogre::Real t = mItemElements.front()->_getDerivedTop() * om.getViewportHeight() + 5;\n					Ogre::Real r = l + mItemElements.back()->getWidth() - 10;\n					Ogre::Real b = mItemElements.back()->_getDerivedTop() * om.getViewportHeight() +\n						mItemElements.back()->getHeight() - 5;\n\n					if (cursorPos.x >= l && cursorPos.x <= r && cursorPos.y >= t && cursorPos.y <= b)\n					{\n						if (mHighlightIndex != mSelectionIndex) selectItem(mHighlightIndex);\n						retract();\n					}\n				}\n			}\n			else\n			{\n				if (mItems.size() < 2) return;   // don't waste time showing a menu if there's no choice\n\n				if (isCursorOver(mSmallBox, cursorPos, 4))\n				{\n					mExpandedBox->show();\n					mSmallBox->hide();\n\n					// calculate how much vertical space we need\n					Ogre::Real idealHeight = mItemsShown * (mSmallBox->getHeight() - 8) + 20;\n					mExpandedBox->setHeight(idealHeight);\n					mScrollTrack->setHeight(mExpandedBox->getHeight() - 20);\n\n					mExpandedBox->setLeft(mSmallBox->getLeft() - 4);\n\n					// if the expanded menu goes down off the screen, make it go up instead\n					if (mSmallBox->_getDerivedTop() * om.getViewportHeight() + idealHeight > om.getViewportHeight())\n					{\n						mExpandedBox->setTop(mSmallBox->getTop() + mSmallBox->getHeight() - idealHeight + 3);\n						// if we're in thick style, hide the caption because it will interfere with the expanded menu\n						if (mTextArea->getHorizontalAlignment() == Ogre::GHA_CENTER) mTextArea->hide();\n					}\n					else mExpandedBox->setTop(mSmallBox->getTop() + 3);\n\n					mExpanded = true;\n					mHighlightIndex = mSelectionIndex;\n					setDisplayIndex(mHighlightIndex);\n\n					if (mItemsShown < mItems.size())  // update scrollbar position\n					{\n						mScrollHandle->show();\n						Ogre::Real lowerBoundary = mScrollTrack->getHeight() - mScrollHandle->getHeight();\n						mScrollHandle->setTop((int)(mDisplayIndex * lowerBoundary / (mItems.size() - mItemElements.size())));\n					}\n					else mScrollHandle->hide();\n				}\n			}\n		}\n\n		void _cursorReleased(const Ogre::Vector2& cursorPos)\n		{\n			mDragging = false;\n		}\n\n		void _cursorMoved(const Ogre::Vector2& cursorPos)\n		{\n			Ogre::OverlayManager& om = Ogre::OverlayManager::getSingleton();\n\n			if (mExpanded)\n			{\n				if (mDragging)\n				{\n					Ogre::Vector2 co = Widget::cursorOffset(mScrollHandle, cursorPos);\n					Ogre::Real newTop = mScrollHandle->getTop() + co.y - mDragOffset;\n					Ogre::Real lowerBoundary = mScrollTrack->getHeight() - mScrollHandle->getHeight();\n					mScrollHandle->setTop(Ogre::Math::Clamp<int>((int)newTop, 0, (int)lowerBoundary));\n\n					Ogre::Real scrollPercentage = Ogre::Math::Clamp<Ogre::Real>(newTop / lowerBoundary, 0, 1);\n					int newIndex = (int) (scrollPercentage * (mItems.size() - mItemElements.size()) + 0.5);\n					if (newIndex != mDisplayIndex) setDisplayIndex(newIndex);\n					return;\n				}\n\n				Ogre::Real l = mItemElements.front()->_getDerivedLeft() * om.getViewportWidth() + 5;\n				Ogre::Real t = mItemElements.front()->_getDerivedTop() * om.getViewportHeight() + 5;\n				Ogre::Real r = l + mItemElements.back()->getWidth() - 10;\n				Ogre::Real b = mItemElements.back()->_getDerivedTop() * om.getViewportHeight() +\n					mItemElements.back()->getHeight() - 5;\n\n				if (cursorPos.x >= l && cursorPos.x <= r && cursorPos.y >= t && cursorPos.y <= b)\n				{\n					int newIndex = (int)(mDisplayIndex + (cursorPos.y - t) / (b - t) * mItemElements.size());\n					if (mHighlightIndex != newIndex)\n					{\n						mHighlightIndex = newIndex;\n						setDisplayIndex(mDisplayIndex);\n					}\n				}\n			}\n			else\n			{\n				if (isCursorOver(mSmallBox, cursorPos, 4))\n				{\n					mSmallBox->setMaterialName(\"SdkTrays/MiniTextBox/Over\");\n					mSmallBox->setBorderMaterialName(\"SdkTrays/MiniTextBox/Over\");\n					mCursorOver = true;\n				}\n				else\n				{\n					if (mCursorOver)\n					{\n						mSmallBox->setMaterialName(\"SdkTrays/MiniTextBox\");\n						mSmallBox->setBorderMaterialName(\"SdkTrays/MiniTextBox\");\n						mCursorOver = false;\n					}\n				}\n			}\n		}\n\n		void _focusLost()\n		{\n			if (mExpandedBox->isVisible()) retract();\n		}\n\n	protected:\n\n		/*-----------------------------------------------------------------------------\n		| Internal method - sets which item goes at the top of the expanded menu.\n		-----------------------------------------------------------------------------*/\n		void setDisplayIndex(unsigned int index)\n		{\n			index = std::min<int>(index, mItems.size() - mItemElements.size());\n			mDisplayIndex = index;\n			Ogre::BorderPanelOverlayElement* ie;\n			Ogre::TextAreaOverlayElement* ta;\n\n			for (int i = 0; i < (int)mItemElements.size(); i++)\n			{\n				ie = mItemElements[i];\n				ta = (Ogre::TextAreaOverlayElement*)ie->getChild(ie->getName() + \"/MenuItemText\");\n\n				fitCaptionToArea(mItems[mDisplayIndex + i], ta, ie->getWidth() - 2 * ta->getLeft());\n\n				if ((mDisplayIndex + i) == mHighlightIndex)\n				{\n					ie->setMaterialName(\"SdkTrays/MiniTextBox/Over\");\n					ie->setBorderMaterialName(\"SdkTrays/MiniTextBox/Over\");\n				}\n				else\n				{\n					ie->setMaterialName(\"SdkTrays/MiniTextBox\");\n					ie->setBorderMaterialName(\"SdkTrays/MiniTextBox\");\n				}\n			}\n		}\n\n		/*-----------------------------------------------------------------------------\n		| Internal method - cleans up an expanded menu.\n		-----------------------------------------------------------------------------*/\n		void retract()\n		{\n			mDragging = false;\n			mExpanded = false;\n			mExpandedBox->hide();\n			mTextArea->show();\n			mSmallBox->show();\n			mSmallBox->setMaterialName(\"SdkTrays/MiniTextBox\");\n			mSmallBox->setBorderMaterialName(\"SdkTrays/MiniTextBox\");\n		}\n\n		Ogre::BorderPanelOverlayElement* mSmallBox;\n		Ogre::BorderPanelOverlayElement* mExpandedBox;\n		Ogre::TextAreaOverlayElement* mTextArea;\n		Ogre::TextAreaOverlayElement* mSmallTextArea;\n		Ogre::BorderPanelOverlayElement* mScrollTrack;\n		Ogre::PanelOverlayElement* mScrollHandle;\n		std::vector<Ogre::BorderPanelOverlayElement*> mItemElements;\n		unsigned int mMaxItemsShown;\n		unsigned int mItemsShown;\n		bool mCursorOver;\n		bool mExpanded;\n		bool mFitToContents;\n		bool mDragging;\n		Ogre::StringVector mItems;\n		int mSelectionIndex;\n		int mHighlightIndex;\n		int mDisplayIndex;\n		Ogre::Real mDragOffset;\n	};\n\n	/*=============================================================================\n	| Basic label widget.\n	=============================================================================*/\n	class Label : public Widget\n	{\n	public:\n\n		// Do not instantiate any widgets directly. Use SdkTrayManager.\n		Label(const Ogre::String& name, const Ogre::DisplayString& caption, Ogre::Real width)\n		{\n			mElement = Ogre::OverlayManager::getSingleton().createOverlayElementFromTemplate(\"SdkTrays/Label\", \"BorderPanel\", name);\n			mTextArea = (Ogre::TextAreaOverlayElement*)((Ogre::OverlayContainer*)mElement)->getChild(getName() + \"/LabelCaption\");\n#if OGRE_PLATFORM == OGRE_PLATFORM_APPLE_IOS\n            mTextArea->setCharHeight(mTextArea->getCharHeight() - 3);\n#endif\n			setCaption(caption);\n			if (width <= 0) mFitToTray = true;\n			else\n			{\n				mFitToTray = false;\n				mElement->setWidth(width);\n			}\n		}\n\n		const Ogre::DisplayString& getCaption()\n		{\n			return mTextArea->getCaption();\n		}\n\n		void setCaption(const Ogre::DisplayString& caption)\n		{\n			mTextArea->setCaption(caption);\n		}\n\n		void _cursorPressed(const Ogre::Vector2& cursorPos)\n		{\n			if (mListener && isCursorOver(mElement, cursorPos, 3)) mListener->labelHit(this);\n		}\n\n		bool _isFitToTray()\n		{\n			return mFitToTray;\n		}\n\n	protected:\n\n		Ogre::TextAreaOverlayElement* mTextArea;\n		bool mFitToTray;\n	};\n\n	/*=============================================================================\n	| Basic separator widget.\n	=============================================================================*/\n	class Separator : public Widget\n	{\n	public:\n\n		// Do not instantiate any widgets directly. Use SdkTrayManager.\n		Separator(const Ogre::String& name, Ogre::Real width)\n		{\n			mElement = Ogre::OverlayManager::getSingleton().createOverlayElementFromTemplate(\"SdkTrays/Separator\", \"Panel\", name);\n			if (width <= 0) mFitToTray = true;\n			else\n			{\n				mFitToTray = false;\n				mElement->setWidth(width);\n			}\n		}\n\n		bool _isFitToTray()\n		{\n			return mFitToTray;\n		}\n\n	protected:\n\n		bool mFitToTray;\n	};\n\n	/*=============================================================================\n	| Basic slider widget.\n	=============================================================================*/\n	class Slider : public Widget\n	{\n	public:\n\n		// Do not instantiate any widgets directly. Use SdkTrayManager.\n		Slider(const Ogre::String& name, const Ogre::DisplayString& caption, Ogre::Real width, Ogre::Real trackWidth,\n			Ogre::Real valueBoxWidth, Ogre::Real minValue, Ogre::Real maxValue, unsigned int snaps)\n			: mDragOffset(0.0f)\n			, mValue(0.0f)\n			, mMinValue(0.0f)\n			, mMaxValue(0.0f)\n			, mInterval(0.0f)\n		{\n			mDragging = false;\n			mFitToContents = false;\n			mElement = Ogre::OverlayManager::getSingleton().createOverlayElementFromTemplate\n				(\"SdkTrays/Slider\", \"BorderPanel\", name);\n			mElement->setWidth(width);\n			Ogre::OverlayContainer* c = (Ogre::OverlayContainer*)mElement;\n			mTextArea = (Ogre::TextAreaOverlayElement*)c->getChild(getName() + \"/SliderCaption\");\n			Ogre::OverlayContainer* valueBox = (Ogre::OverlayContainer*)c->getChild(getName() + \"/SliderValueBox\");\n			valueBox->setWidth(valueBoxWidth);\n			valueBox->setLeft(-(valueBoxWidth + 5));\n			mValueTextArea = (Ogre::TextAreaOverlayElement*)valueBox->getChild(valueBox->getName() + \"/SliderValueText\");\n			mTrack = (Ogre::BorderPanelOverlayElement*)c->getChild(getName() + \"/SliderTrack\");\n			mHandle = (Ogre::PanelOverlayElement*)mTrack->getChild(mTrack->getName() + \"/SliderHandle\");\n#if OGRE_PLATFORM == OGRE_PLATFORM_APPLE_IOS\n            mTextArea->setCharHeight(mTextArea->getCharHeight() - 3);\n            mValueTextArea->setCharHeight(mValueTextArea->getCharHeight() - 3);\n#endif\n            \n			if (trackWidth <= 0)  // tall style\n			{\n				mTrack->setWidth(width - 16);\n			}\n			else  // long style\n			{\n				if (width <= 0) mFitToContents = true;\n				mElement->setHeight(34);\n				mTextArea->setTop(10);\n				valueBox->setTop(2);\n				mTrack->setTop(-23);\n				mTrack->setWidth(trackWidth);\n				mTrack->setHorizontalAlignment(Ogre::GHA_RIGHT);\n				mTrack->setLeft(-(trackWidth + valueBoxWidth + 5));\n			}\n\n			setCaption(caption);\n			setRange(minValue, maxValue, snaps, false);\n		}\n\n		/*-----------------------------------------------------------------------------\n		| Sets the minimum value, maximum value, and the number of snapping points.\n		-----------------------------------------------------------------------------*/\n		void setRange(Ogre::Real minValue, Ogre::Real maxValue, unsigned int snaps, bool notifyListener = true)\n		{\n			mMinValue = minValue;\n			mMaxValue = maxValue;\n\n			if (snaps <= 1 || mMinValue >= mMaxValue)\n			{\n				mInterval = 0;\n				mHandle->hide();\n				mValue = minValue;\n				if (snaps == 1) mValueTextArea->setCaption(Ogre::StringConverter::toString(mMinValue));\n				else mValueTextArea->setCaption(\"\");\n			}\n			else\n			{\n				mHandle->show();\n				mInterval = (maxValue - minValue) / (snaps - 1);\n				setValue(minValue, notifyListener);\n			}\n		}\n\n		const Ogre::DisplayString& getValueCaption()\n		{\n			return mValueTextArea->getCaption();\n		}\n		\n		/*-----------------------------------------------------------------------------\n		| You can use this method to manually format how the value is displayed.\n		-----------------------------------------------------------------------------*/\n		void setValueCaption(const Ogre::DisplayString& caption)\n		{\n			mValueTextArea->setCaption(caption);\n		}\n\n		void setValue(Ogre::Real value, bool notifyListener = true)\n		{\n			if (mInterval == 0) return;\n\n			mValue = Ogre::Math::Clamp<Ogre::Real>(value, mMinValue, mMaxValue);\n\n			setValueCaption(Ogre::StringConverter::toString(mValue));\n\n			if (mListener && notifyListener) mListener->sliderMoved(this);\n\n			if (!mDragging) mHandle->setLeft((int)((mValue - mMinValue) / (mMaxValue - mMinValue) *\n				(mTrack->getWidth() - mHandle->getWidth())));\n		}\n\n		Ogre::Real getValue()\n		{\n			return mValue;\n		}\n\n		const Ogre::DisplayString& getCaption()\n		{\n			return mTextArea->getCaption();\n		}\n\n		void setCaption(const Ogre::DisplayString& caption)\n		{\n			mTextArea->setCaption(caption);\n\n			if (mFitToContents) mElement->setWidth(getCaptionWidth(caption, mTextArea) +\n				mValueTextArea->getParent()->getWidth() + mTrack->getWidth() + 26);\n		}\n\n		void _cursorPressed(const Ogre::Vector2& cursorPos)\n		{\n			if (!mHandle->isVisible()) return;\n\n			Ogre::Vector2 co = Widget::cursorOffset(mHandle, cursorPos);\n\n			if (co.squaredLength() <= 81)\n			{\n				mDragging = true;\n				mDragOffset = co.x;\n			}\n			else if (Widget::isCursorOver(mTrack, cursorPos))\n			{\n				Ogre::Real newLeft = mHandle->getLeft() + co.x;\n				Ogre::Real rightBoundary = mTrack->getWidth() - mHandle->getWidth();\n\n				mHandle->setLeft(Ogre::Math::Clamp<int>((int)newLeft, 0, (int)rightBoundary));\n				setValue(getSnappedValue(newLeft / rightBoundary));\n			}\n		}\n\n		void _cursorReleased(const Ogre::Vector2& cursorPos)\n		{\n			if (mDragging)\n			{\n				mDragging = false;\n				mHandle->setLeft((int)((mValue - mMinValue) / (mMaxValue - mMinValue) *\n					(mTrack->getWidth() - mHandle->getWidth())));\n			}\n		}\n\n		void _cursorMoved(const Ogre::Vector2& cursorPos)\n		{\n			if (mDragging)\n			{\n				Ogre::Vector2 co = Widget::cursorOffset(mHandle, cursorPos);\n				Ogre::Real newLeft = mHandle->getLeft() + co.x - mDragOffset;\n				Ogre::Real rightBoundary = mTrack->getWidth() - mHandle->getWidth();\n\n				mHandle->setLeft(Ogre::Math::Clamp<int>((int)newLeft, 0, (int)rightBoundary));\n				setValue(getSnappedValue(newLeft / rightBoundary));\n			}\n		}\n\n		void _focusLost()\n		{\n			mDragging = false;\n		}\n\n	protected:\n\n		/*-----------------------------------------------------------------------------\n		| Internal method - given a percentage (from left to right), gets the\n		| value of the nearest marker.\n		-----------------------------------------------------------------------------*/\n		Ogre::Real getSnappedValue(Ogre::Real percentage)\n		{\n			percentage = Ogre::Math::Clamp<Ogre::Real>(percentage, 0, 1);\n			unsigned int whichMarker = (unsigned int) (percentage * (mMaxValue - mMinValue) / mInterval + 0.5);\n			return whichMarker * mInterval + mMinValue;\n		}\n\n		Ogre::TextAreaOverlayElement* mTextArea;\n		Ogre::TextAreaOverlayElement* mValueTextArea;\n		Ogre::BorderPanelOverlayElement* mTrack;\n		Ogre::PanelOverlayElement* mHandle;\n		bool mDragging;\n		bool mFitToContents;\n		Ogre::Real mDragOffset;\n		Ogre::Real mValue;\n		Ogre::Real mMinValue;\n		Ogre::Real mMaxValue;\n		Ogre::Real mInterval;\n	};\n\n	/*=============================================================================\n	| Basic parameters panel widget.\n	=============================================================================*/\n	class ParamsPanel : public Widget\n	{\n	public:\n\n		// Do not instantiate any widgets directly. Use SdkTrayManager.\n		ParamsPanel(const Ogre::String& name, Ogre::Real width, unsigned int lines)\n		{\n			mElement = Ogre::OverlayManager::getSingleton().createOverlayElementFromTemplate\n				(\"SdkTrays/ParamsPanel\", \"BorderPanel\", name);\n			Ogre::OverlayContainer* c = (Ogre::OverlayContainer*)mElement;\n			mNamesArea = (Ogre::TextAreaOverlayElement*)c->getChild(getName() + \"/ParamsPanelNames\");\n			mValuesArea = (Ogre::TextAreaOverlayElement*)c->getChild(getName() + \"/ParamsPanelValues\");\n#if OGRE_PLATFORM == OGRE_PLATFORM_APPLE_IOS\n            mNamesArea->setCharHeight(mNamesArea->getCharHeight() - 3);\n            mValuesArea->setCharHeight(mValuesArea->getCharHeight() - 3);\n#endif\n			mElement->setWidth(width);\n			mElement->setHeight(mNamesArea->getTop() * 2 + lines * mNamesArea->getCharHeight());\n		}\n\n		void setAllParamNames(const Ogre::StringVector& paramNames)\n		{\n			mNames = paramNames;\n			mValues.clear();\n			mValues.resize(mNames.size(), \"\");\n			mElement->setHeight(mNamesArea->getTop() * 2 + mNames.size() * mNamesArea->getCharHeight());\n			updateText();\n		}\n\n		const Ogre::StringVector& getAllParamNames()\n		{\n			return mNames;\n		}\n\n		void setAllParamValues(const Ogre::StringVector& paramValues)\n		{\n			mValues = paramValues;\n			mValues.resize(mNames.size(), \"\");\n			updateText();\n		}\n\n		void setParamValue(const Ogre::DisplayString& paramName, const Ogre::DisplayString& paramValue)\n		{\n			for (unsigned int i = 0; i < mNames.size(); i++)\n			{\n				if (mNames[i] == DISPLAY_STRING_TO_STRING(paramName))\n				{\n					mValues[i] = DISPLAY_STRING_TO_STRING(paramValue);\n					updateText();\n					return;\n				}\n			}\n\n			Ogre::String desc = \"ParamsPanel \\\"\" + getName() + \"\\\" has no parameter \\\"\" + DISPLAY_STRING_TO_STRING(paramName) + \"\\\".\";\n			OGRE_EXCEPT(Ogre::Exception::ERR_ITEM_NOT_FOUND, desc, \"ParamsPanel::setParamValue\");\n		}\n\n		void setParamValue(unsigned int index, const Ogre::DisplayString& paramValue)\n		{\n			if (index >= mNames.size())\n			{\n				Ogre::String desc = \"ParamsPanel \\\"\" + getName() + \"\\\" has no parameter at position \" +\n					Ogre::StringConverter::toString(index) + \".\";\n				OGRE_EXCEPT(Ogre::Exception::ERR_ITEM_NOT_FOUND, desc, \"ParamsPanel::setParamValue\");\n			}\n\n			mValues[index] = DISPLAY_STRING_TO_STRING(paramValue);\n			updateText();\n		}\n\n		Ogre::DisplayString getParamValue(const Ogre::DisplayString& paramName)\n		{\n			for (unsigned int i = 0; i < mNames.size(); i++)\n			{\n				if (mNames[i] == DISPLAY_STRING_TO_STRING(paramName)) return mValues[i];\n			}\n			\n			Ogre::String desc = \"ParamsPanel \\\"\" + getName() + \"\\\" has no parameter \\\"\" + DISPLAY_STRING_TO_STRING(paramName) + \"\\\".\";\n			OGRE_EXCEPT(Ogre::Exception::ERR_ITEM_NOT_FOUND, desc, \"ParamsPanel::getParamValue\");\n			return \"\";\n		}\n\n		Ogre::DisplayString getParamValue(unsigned int index)\n		{\n			if (index >= mNames.size())\n			{\n				Ogre::String desc = \"ParamsPanel \\\"\" + getName() + \"\\\" has no parameter at position \" +\n					Ogre::StringConverter::toString(index) + \".\";\n				OGRE_EXCEPT(Ogre::Exception::ERR_ITEM_NOT_FOUND, desc, \"ParamsPanel::getParamValue\");\n			}\n			\n			return mValues[index];\n		}\n\n		const Ogre::StringVector& getAllParamValues()\n		{\n			return mValues;\n		}\n\n	protected:\n\n		/*-----------------------------------------------------------------------------\n		| Internal method - updates text areas based on name and value lists.\n		-----------------------------------------------------------------------------*/\n		void updateText()\n		{\n			Ogre::DisplayString namesDS;\n			Ogre::DisplayString valuesDS;\n\n			for (unsigned int i = 0; i < mNames.size(); i++)\n			{\n				namesDS.append(mNames[i] + \":\\n\");\n				valuesDS.append(mValues[i] + \"\\n\");\n			}\n\n			mNamesArea->setCaption(namesDS);\n			mValuesArea->setCaption(valuesDS);\n		}\n\n		Ogre::TextAreaOverlayElement* mNamesArea;\n		Ogre::TextAreaOverlayElement* mValuesArea;\n		Ogre::StringVector mNames;\n		Ogre::StringVector mValues;\n	};\n\n	/*=============================================================================\n	| Basic check box widget.\n	=============================================================================*/\n	class CheckBox : public Widget\n	{\n	public:\n\n		// Do not instantiate any widgets directly. Use SdkTrayManager.\n		CheckBox(const Ogre::String& name, const Ogre::DisplayString& caption, Ogre::Real width)\n		{\n			mCursorOver = false;\n			mFitToContents = width <= 0;\n			mElement = Ogre::OverlayManager::getSingleton().createOverlayElementFromTemplate\n				(\"SdkTrays/CheckBox\", \"BorderPanel\", name);\n			Ogre::OverlayContainer* c = (Ogre::OverlayContainer*)mElement;\n			mTextArea = (Ogre::TextAreaOverlayElement*)c->getChild(getName() + \"/CheckBoxCaption\");\n			mSquare = (Ogre::BorderPanelOverlayElement*)c->getChild(getName() + \"/CheckBoxSquare\");\n			mX = mSquare->getChild(mSquare->getName() + \"/CheckBoxX\");\n			mX->hide();\n			mElement->setWidth(width);\n#if OGRE_PLATFORM == OGRE_PLATFORM_APPLE_IOS\n            mTextArea->setCharHeight(mTextArea->getCharHeight() - 3);\n#endif\n			setCaption(caption);\n		}\n\n		const Ogre::DisplayString& getCaption()\n		{\n			return mTextArea->getCaption();\n		}\n\n		void setCaption(const Ogre::DisplayString& caption)\n		{\n			mTextArea->setCaption(caption);\n			if (mFitToContents) mElement->setWidth(getCaptionWidth(caption, mTextArea) + mSquare->getWidth() + 23);\n		}\n\n		bool isChecked()\n		{\n			return mX->isVisible();\n		}\n\n		void setChecked(bool checked, bool notifyListener = true)\n		{\n			if (checked) mX->show();\n			else mX->hide();\n			if (mListener && notifyListener) mListener->checkBoxToggled(this);\n		}\n\n		void toggle(bool notifyListener = true)\n		{\n			setChecked(!isChecked(), notifyListener);\n		}\n\n		void _cursorPressed(const Ogre::Vector2& cursorPos)\n		{\n			if (mCursorOver && mListener) toggle();\n		}\n\n		void _cursorMoved(const Ogre::Vector2& cursorPos)\n		{\n			if (isCursorOver(mSquare, cursorPos, 5))\n			{\n				if (!mCursorOver)\n				{\n					mCursorOver = true;\n					mSquare->setMaterialName(\"SdkTrays/MiniTextBox/Over\");\n					mSquare->setBorderMaterialName(\"SdkTrays/MiniTextBox/Over\");\n				}\n			}\n			else\n			{\n				if (mCursorOver)\n				{\n					mCursorOver = false;\n					mSquare->setMaterialName(\"SdkTrays/MiniTextBox\");\n					mSquare->setBorderMaterialName(\"SdkTrays/MiniTextBox\");\n				}\n			}\n		}\n\n		void _focusLost()\n		{\n			mSquare->setMaterialName(\"SdkTrays/MiniTextBox\");\n			mSquare->setBorderMaterialName(\"SdkTrays/MiniTextBox\");\n			mCursorOver = false;\n		}\n\n	protected:\n\n		Ogre::TextAreaOverlayElement* mTextArea;\n		Ogre::BorderPanelOverlayElement* mSquare;\n		Ogre::OverlayElement* mX;\n		bool mFitToContents;\n		bool mCursorOver;\n	};\n\n	/*=============================================================================\n	| Custom, decorative widget created from a template.\n	=============================================================================*/\n	class DecorWidget : public Widget\n	{\n	public:\n\n		// Do not instantiate any widgets directly. Use SdkTrayManager.\n		DecorWidget(const Ogre::String& name, const Ogre::String& templateName)\n		{\n			mElement = Ogre::OverlayManager::getSingleton().createOverlayElementFromTemplate(templateName, \"\", name);\n		}\n	};\n\n	/*=============================================================================\n	| Basic progress bar widget.\n	=============================================================================*/\n	class ProgressBar : public Widget\n	{\n	public:\n\n		// Do not instantiate any widgets directly. Use SdkTrayManager.\n		ProgressBar(const Ogre::String& name, const Ogre::DisplayString& caption, Ogre::Real width, Ogre::Real commentBoxWidth)\n			: mProgress(0.0f)\n		{\n			mElement = Ogre::OverlayManager::getSingleton().createOverlayElementFromTemplate\n				(\"SdkTrays/ProgressBar\", \"BorderPanel\", name);\n			mElement->setWidth(width);\n			Ogre::OverlayContainer* c = (Ogre::OverlayContainer*)mElement;\n			mTextArea = (Ogre::TextAreaOverlayElement*)c->getChild(getName() + \"/ProgressCaption\");\n			Ogre::OverlayContainer* commentBox = (Ogre::OverlayContainer*)c->getChild(getName() + \"/ProgressCommentBox\");\n			commentBox->setWidth(commentBoxWidth);\n			commentBox->setLeft(-(commentBoxWidth + 5));\n			mCommentTextArea = (Ogre::TextAreaOverlayElement*)commentBox->getChild(commentBox->getName() + \"/ProgressCommentText\");\n			mMeter = c->getChild(getName() + \"/ProgressMeter\");\n			mMeter->setWidth(width - 10);\n			mFill = ((Ogre::OverlayContainer*)mMeter)->getChild(mMeter->getName() + \"/ProgressFill\");\n			setCaption(caption);\n		}\n\n		/*-----------------------------------------------------------------------------\n		| Sets the progress as a percentage.\n		-----------------------------------------------------------------------------*/\n		void setProgress(Ogre::Real progress)\n		{\n			mProgress = Ogre::Math::Clamp<Ogre::Real>(progress, 0, 1);\n			mFill->setWidth(std::max<int>((int)mFill->getHeight(), (int)(mProgress * (mMeter->getWidth() - 2 * mFill->getLeft()))));\n		}\n\n		/*-----------------------------------------------------------------------------\n		| Gets the progress as a percentage.\n		-----------------------------------------------------------------------------*/\n		Ogre::Real getProgress()\n		{\n			return mProgress;\n		}\n\n		const Ogre::DisplayString& getCaption()\n		{\n			return mTextArea->getCaption();\n		}\n\n		void setCaption(const Ogre::DisplayString& caption)\n		{\n			mTextArea->setCaption(caption);\n		}\n\n		const Ogre::DisplayString& getComment()\n		{\n			return mCommentTextArea->getCaption();\n		}\n\n		void setComment(const Ogre::DisplayString& comment)\n		{\n			mCommentTextArea->setCaption(comment);\n		}\n\n\n	protected:\n\n		Ogre::TextAreaOverlayElement* mTextArea;\n		Ogre::TextAreaOverlayElement* mCommentTextArea;\n		Ogre::OverlayElement* mMeter;\n		Ogre::OverlayElement* mFill;\n		Ogre::Real mProgress;\n	};\n\n	/*=============================================================================\n	| Main class to manage a cursor, backdrop, trays and widgets.\n	=============================================================================*/\n	class SdkTrayManager : public SdkTrayListener, public Ogre::ResourceGroupListener\n    {\n    public:\n\n		/*-----------------------------------------------------------------------------\n		| Creates backdrop, cursor, and trays.\n		-----------------------------------------------------------------------------*/\n#if (OGRE_PLATFORM == OGRE_PLATFORM_APPLE_IOS) || (OGRE_PLATFORM == OGRE_PLATFORM_ANDROID)\n		SdkTrayManager(const Ogre::String& name, Ogre::RenderWindow* window, OIS::MultiTouch* mouse, SdkTrayListener* listener = 0) :\n#else\n		SdkTrayManager(const Ogre::String& name, Ogre::RenderWindow* window, OIS::Mouse* mouse, SdkTrayListener* listener = 0) :\n#endif\n		  mName(name), mWindow(window), mMouse(mouse), mWidgetDeathRow(), mListener(listener), mWidgetPadding(8),\n                mWidgetSpacing(2), mTrayPadding(0), mTrayDrag(false), mExpandedMenu(0), mDialog(0), mOk(0), mYes(0),\n                mNo(0), mCursorWasVisible(false), mFpsLabel(0), mStatsPanel(0), mLogo(0), mLoadBar(0),\n				mGroupInitProportion(0.0f), mGroupLoadProportion(0.0f), mLoadInc(0.0f)\n		{\n            mTimer = Ogre::Root::getSingleton().getTimer();\n            mLastStatUpdateTime = 0;\n\n			Ogre::OverlayManager& om = Ogre::OverlayManager::getSingleton();\n\n			Ogre::String nameBase = mName + \"/\";\n			std::replace(nameBase.begin(), nameBase.end(), ' ', '_');\n\n			// create overlay layers for everything\n			mBackdropLayer = om.create(nameBase + \"BackdropLayer\");\n			mTraysLayer = om.create(nameBase + \"WidgetsLayer\");\n			mPriorityLayer = om.create(nameBase + \"PriorityLayer\");\n			mCursorLayer = om.create(nameBase + \"CursorLayer\");\n			mBackdropLayer->setZOrder(100);\n			mTraysLayer->setZOrder(200);\n			mPriorityLayer->setZOrder(300);\n			mCursorLayer->setZOrder(400);\n\n			// make backdrop and cursor overlay containers\n			mCursor = (Ogre::OverlayContainer*)om.createOverlayElementFromTemplate(\"SdkTrays/Cursor\", \"Panel\", nameBase + \"Cursor\");\n			mCursorLayer->add2D(mCursor);\n			mBackdrop = (Ogre::OverlayContainer*)om.createOverlayElement(\"Panel\", nameBase + \"Backdrop\");\n			mBackdropLayer->add2D(mBackdrop);\n			mDialogShade = (Ogre::OverlayContainer*)om.createOverlayElement(\"Panel\", nameBase + \"DialogShade\");\n			mDialogShade->setMaterialName(\"SdkTrays/Shade\");\n			mDialogShade->hide();\n			mPriorityLayer->add2D(mDialogShade);\n\n			Ogre::String trayNames[] =\n			{ \"TopLeft\", \"Top\", \"TopRight\", \"Left\", \"Center\", \"Right\", \"BottomLeft\", \"Bottom\", \"BottomRight\" };\n\n			for (unsigned int i = 0; i < 9; i++)    // make the real trays\n			{\n				mTrays[i] = (Ogre::OverlayContainer*)om.createOverlayElementFromTemplate\n					(\"SdkTrays/Tray\", \"BorderPanel\", nameBase + trayNames[i] + \"Tray\");\n				mTraysLayer->add2D(mTrays[i]);\n\n				mTrayWidgetAlign[i] = Ogre::GHA_CENTER;\n\n				// align trays based on location\n				if (i == TL_TOP || i == TL_CENTER || i == TL_BOTTOM) mTrays[i]->setHorizontalAlignment(Ogre::GHA_CENTER);\n				if (i == TL_LEFT || i == TL_CENTER || i == TL_RIGHT) mTrays[i]->setVerticalAlignment(Ogre::GVA_CENTER);\n				if (i == TL_TOPRIGHT || i == TL_RIGHT || i == TL_BOTTOMRIGHT) mTrays[i]->setHorizontalAlignment(Ogre::GHA_RIGHT);\n				if (i == TL_BOTTOMLEFT || i == TL_BOTTOM || i == TL_BOTTOMRIGHT) mTrays[i]->setVerticalAlignment(Ogre::GVA_BOTTOM);\n			}\n\n			// create the null tray for free-floating widgets\n			mTrays[9] = (Ogre::OverlayContainer*)om.createOverlayElement(\"Panel\", nameBase + \"NullTray\");\n			mTrayWidgetAlign[9] = Ogre::GHA_LEFT;\n			mTraysLayer->add2D(mTrays[9]);\n			adjustTrays();\n			\n			showTrays();\n			showCursor();\n		}\n\n		/*-----------------------------------------------------------------------------\n		| Destroys background, cursor, widgets, and trays.\n		-----------------------------------------------------------------------------*/\n		virtual ~SdkTrayManager()\n		{\n			Ogre::OverlayManager& om = Ogre::OverlayManager::getSingleton();\n\n			destroyAllWidgets();\n\n			for (unsigned int i = 0; i < mWidgetDeathRow.size(); i++)   // delete widgets queued for destruction\n			{\n				delete mWidgetDeathRow[i];\n			}\n			mWidgetDeathRow.clear();\n\n			om.destroy(mBackdropLayer);\n			om.destroy(mTraysLayer);\n			om.destroy(mPriorityLayer);\n			om.destroy(mCursorLayer);\n\n			closeDialog();\n			hideLoadingBar();\n\n			Widget::nukeOverlayElement(mBackdrop);\n			Widget::nukeOverlayElement(mCursor);\n			Widget::nukeOverlayElement(mDialogShade);\n\n			for (unsigned int i = 0; i < 10; i++)\n			{\n				Widget::nukeOverlayElement(mTrays[i]);\n			}\n		}\n\n		/*-----------------------------------------------------------------------------\n		| Converts a 2D screen coordinate (in pixels) to a 3D ray into the scene.\n		-----------------------------------------------------------------------------*/\n		static Ogre::Ray screenToScene(Ogre::Camera* cam, const Ogre::Vector2& pt)\n		{\n			return cam->getCameraToViewportRay(pt.x, pt.y);\n		}\n\n		/*-----------------------------------------------------------------------------\n		| Converts a 3D scene position to a 2D screen position (in relative screen size, 0.0-1.0).\n		-----------------------------------------------------------------------------*/\n		static Ogre::Vector2 sceneToScreen(Ogre::Camera* cam, const Ogre::Vector3& pt)\n		{\n			Ogre::Vector3 result = cam->getProjectionMatrix() * cam->getViewMatrix() * pt;\n			return Ogre::Vector2((result.x + 1) / 2, (-result.y + 1) / 2);\n		}\n\n		// these methods get the underlying overlays and overlay elements\n\n		Ogre::OverlayContainer* getTrayContainer(TrayLocation trayLoc) { return mTrays[trayLoc]; }\n		Ogre::Overlay* getBackdropLayer() { return mBackdropLayer; }\n		Ogre::Overlay* getTraysLayer() { return mTraysLayer; }\n		Ogre::Overlay* getCursorLayer() { return mCursorLayer; }\n		Ogre::OverlayContainer* getBackdropContainer() { return mBackdrop; }\n		Ogre::OverlayContainer* getCursorContainer() { return mCursor; }\n		Ogre::OverlayElement* getCursorImage() { return mCursor->getChild(mCursor->getName() + \"/CursorImage\"); }\n\n		void setListener(SdkTrayListener* listener)\n		{\n			mListener = listener;\n		}\n\n		SdkTrayListener* getListener()\n		{\n			return mListener;\n		}\n\n		void showAll()\n		{\n			showBackdrop();\n			showTrays();\n			showCursor();\n		}\n\n		void hideAll()\n		{\n			hideBackdrop();\n			hideTrays();\n			hideCursor();\n		}\n\n		/*-----------------------------------------------------------------------------\n		| Displays specified material on backdrop, or the last material used if\n		| none specified. Good for pause menus like in the browser.\n		-----------------------------------------------------------------------------*/\n		void showBackdrop(const Ogre::String& materialName = Ogre::StringUtil::BLANK)\n		{\n			if (materialName != Ogre::StringUtil::BLANK) mBackdrop->setMaterialName(materialName);\n			mBackdropLayer->show();\n		}\n\n		void hideBackdrop()\n		{\n			mBackdropLayer->hide();\n		}\n\n		/*-----------------------------------------------------------------------------\n		| Displays specified material on cursor, or the last material used if\n		| none specified. Used to change cursor type.\n		-----------------------------------------------------------------------------*/\n		void showCursor(const Ogre::String& materialName = Ogre::StringUtil::BLANK)\n		{\n			if (materialName != Ogre::StringUtil::BLANK) getCursorImage()->setMaterialName(materialName);\n\n			if (!mCursorLayer->isVisible())\n			{\n				mCursorLayer->show();\n				refreshCursor();\n			}\n		}\n\n		void hideCursor()\n		{\n			mCursorLayer->hide();\n\n			// give widgets a chance to reset in case they're in the middle of something\n			for (unsigned int i = 0; i < 10; i++)\n			{\n				for (unsigned int j = 0; j < mWidgets[i].size(); j++)\n				{\n					mWidgets[i][j]->_focusLost();\n				}\n			}\n\n			setExpandedMenu(0);\n		}\n\n		/*-----------------------------------------------------------------------------\n		| Updates cursor position based on unbuffered mouse state. This is necessary\n		| because if the tray manager has been cut off from mouse events for a time,\n		| the cursor position will be out of date.\n		-----------------------------------------------------------------------------*/\n		void refreshCursor()\n		{\n#if (OGRE_NO_VIEWPORT_ORIENTATIONMODE == 0) || (OGRE_PLATFORM == OGRE_PLATFORM_APPLE_IOS)\n            // TODO:\n            // the position should be based on the orientation, for now simply return\n            return;\n#endif\n#if OGRE_PLATFORM == OGRE_PLATFORM_APPLE_IOS\n            std::vector<OIS::MultiTouchState> states = mMouse->getMultiTouchStates();\n            if(states.size() > 0)\n                mCursor->setPosition(states[0].X.abs, states[0].Y.abs);\n#elif OGRE_PLATFORM == OGRE_PLATFORM_ANDROID\n			// TODO: handle cursor positioning\n#else\n			mCursor->setPosition(mMouse->getMouseState().X.abs, mMouse->getMouseState().Y.abs);\n#endif\n		}\n\n		void showTrays()\n		{\n			mTraysLayer->show();\n			mPriorityLayer->show();\n		}\n\n		void hideTrays()\n		{\n			mTraysLayer->hide();\n			mPriorityLayer->hide();\n\n			// give widgets a chance to reset in case they're in the middle of something\n			for (unsigned int i = 0; i < 10; i++)\n			{\n				for (unsigned int j = 0; j < mWidgets[i].size(); j++)\n				{\n					mWidgets[i][j]->_focusLost();\n				}\n			}\n\n			setExpandedMenu(0);\n		}\n\n		bool isCursorVisible() { return mCursorLayer->isVisible(); }\n		bool isBackdropVisible() { return mBackdropLayer->isVisible(); }\n		bool areTraysVisible() { return mTraysLayer->isVisible(); }\n\n		/*-----------------------------------------------------------------------------\n		| Sets horizontal alignment of a tray's contents.\n		-----------------------------------------------------------------------------*/\n		void setTrayWidgetAlignment(TrayLocation trayLoc, Ogre::GuiHorizontalAlignment gha)\n		{\n			mTrayWidgetAlign[trayLoc] = gha;\n\n			for (unsigned int i = 0; i < mWidgets[trayLoc].size(); i++)\n			{\n				mWidgets[trayLoc][i]->getOverlayElement()->setHorizontalAlignment(gha);\n			}\n		}\n\n		// padding and spacing methods\n\n		void setWidgetPadding(Ogre::Real padding)\n		{\n			mWidgetPadding = std::max<int>((int)padding, 0);\n			adjustTrays();\n		}\n\n		void setWidgetSpacing(Ogre::Real spacing)\n		{\n			mWidgetSpacing = std::max<int>((int)spacing, 0);\n			adjustTrays();\n		}\n		void setTrayPadding(Ogre::Real padding)\n		{\n			mTrayPadding = std::max<int>((int)padding, 0);\n			adjustTrays();\n		}\n\n		virtual Ogre::Real getWidgetPadding() const { return mWidgetPadding; }\n		virtual Ogre::Real getWidgetSpacing() const { return mWidgetSpacing; }\n		virtual Ogre::Real getTrayPadding() const { return mTrayPadding; }\n\n		/*-----------------------------------------------------------------------------\n		| Fits trays to their contents and snaps them to their anchor locations.\n		-----------------------------------------------------------------------------*/\n		virtual void adjustTrays()\n		{\n			for (unsigned int i = 0; i < 9; i++)   // resizes and hides trays if necessary\n			{\n				Ogre::Real trayWidth = 0;\n				Ogre::Real trayHeight = mWidgetPadding;\n				std::vector<Ogre::OverlayElement*> labelsAndSeps;\n\n				if (mWidgets[i].empty())   // hide tray if empty\n				{\n					mTrays[i]->hide();\n					continue;\n				}\n				else mTrays[i]->show();\n\n				// arrange widgets and calculate final tray size and position\n				for (unsigned int j = 0; j < mWidgets[i].size(); j++)\n				{\n					Ogre::OverlayElement* e = mWidgets[i][j]->getOverlayElement();\n\n					if (j != 0) trayHeight += mWidgetSpacing;   // don't space first widget\n\n					e->setVerticalAlignment(Ogre::GVA_TOP);\n					e->setTop(trayHeight);\n\n					switch (e->getHorizontalAlignment())\n					{\n					case Ogre::GHA_LEFT:\n						e->setLeft(mWidgetPadding);\n						break;\n					case Ogre::GHA_RIGHT:\n						e->setLeft(-(e->getWidth() + mWidgetPadding));\n						break;\n					default:\n						e->setLeft(-(e->getWidth() / 2));\n					}\n\n					// prevents some weird texture filtering problems (just some)\n					e->setPosition((int)e->getLeft(), (int)e->getTop());\n					e->setDimensions((int)e->getWidth(), (int)e->getHeight());\n\n					trayHeight += e->getHeight();\n\n					Label* l = dynamic_cast<Label*>(mWidgets[i][j]);\n					if (l && l->_isFitToTray())\n					{\n						labelsAndSeps.push_back(e);\n						continue;\n					}\n					Separator* s = dynamic_cast<Separator*>(mWidgets[i][j]);\n					if (s && s->_isFitToTray()) \n					{\n						labelsAndSeps.push_back(e);\n						continue;\n					}\n\n					if (e->getWidth() > trayWidth) trayWidth = e->getWidth();\n				}\n\n				// add paddings and resize trays\n				mTrays[i]->setWidth(trayWidth + 2 * mWidgetPadding);\n				mTrays[i]->setHeight(trayHeight + mWidgetPadding);\n\n				for (unsigned int j = 0; j < labelsAndSeps.size(); j++)\n				{\n					labelsAndSeps[j]->setWidth((int)trayWidth);\n					labelsAndSeps[j]->setLeft(-(int)(trayWidth / 2));\n				}\n			}\n\n			for (unsigned int i = 0; i < 9; i++)    // snap trays to anchors\n			{\n				if (i == TL_TOPLEFT || i == TL_LEFT || i == TL_BOTTOMLEFT)\n					mTrays[i]->setLeft(mTrayPadding);\n				if (i == TL_TOP || i == TL_CENTER || i == TL_BOTTOM)\n					mTrays[i]->setLeft(-mTrays[i]->getWidth() / 2);\n				if (i == TL_TOPRIGHT || i == TL_RIGHT || i == TL_BOTTOMRIGHT)\n					mTrays[i]->setLeft(-(mTrays[i]->getWidth() + mTrayPadding));\n\n				if (i == TL_TOPLEFT || i == TL_TOP || i == TL_TOPRIGHT)\n					mTrays[i]->setTop(mTrayPadding);\n				if (i == TL_LEFT || i == TL_CENTER || i == TL_RIGHT)\n					mTrays[i]->setTop(-mTrays[i]->getHeight() / 2);\n				if (i == TL_BOTTOMLEFT || i == TL_BOTTOM || i == TL_BOTTOMRIGHT)\n					mTrays[i]->setTop(-mTrays[i]->getHeight() - mTrayPadding);\n\n				// prevents some weird texture filtering problems (just some)\n				mTrays[i]->setPosition((int)mTrays[i]->getLeft(), (int)mTrays[i]->getTop());\n				mTrays[i]->setDimensions((int)mTrays[i]->getWidth(), (int)mTrays[i]->getHeight());\n			}\n		}\n\n		/*-----------------------------------------------------------------------------\n		| Returns a 3D ray into the scene that is directly underneath the cursor.\n		-----------------------------------------------------------------------------*/\n		Ogre::Ray getCursorRay(Ogre::Camera* cam)\n		{\n			return screenToScene(cam, Ogre::Vector2(mCursor->_getLeft(), mCursor->_getTop()));\n		}\n\n		Button* createButton(TrayLocation trayLoc, const Ogre::String& name, const Ogre::String& caption, Ogre::Real width = 0)\n		{\n			Button* b = new Button(name, caption, width);\n			moveWidgetToTray(b, trayLoc);\n			b->_assignListener(mListener);\n			return b;\n		}\n\n		TextBox* createTextBox(TrayLocation trayLoc, const Ogre::String& name, const Ogre::DisplayString& caption,\n			Ogre::Real width, Ogre::Real height)\n		{\n			TextBox* tb = new TextBox(name, caption, width, height);\n			moveWidgetToTray(tb, trayLoc);\n			tb->_assignListener(mListener);\n			return tb;\n		}\n\n		SelectMenu* createThickSelectMenu(TrayLocation trayLoc, const Ogre::String& name, const Ogre::DisplayString& caption,\n			Ogre::Real width, unsigned int maxItemsShown, const Ogre::StringVector& items = Ogre::StringVector())\n		{\n			SelectMenu* sm = new SelectMenu(name, caption, width, 0, maxItemsShown);\n			moveWidgetToTray(sm, trayLoc);\n			sm->_assignListener(mListener);\n			if (!items.empty()) sm->setItems(items);\n			return sm;\n		}\n\n		SelectMenu* createLongSelectMenu(TrayLocation trayLoc, const Ogre::String& name, const Ogre::DisplayString& caption,\n			Ogre::Real width, Ogre::Real boxWidth, unsigned int maxItemsShown, const Ogre::StringVector& items = Ogre::StringVector())\n		{\n			SelectMenu* sm = new SelectMenu(name, caption, width, boxWidth, maxItemsShown);\n			moveWidgetToTray(sm, trayLoc);\n			sm->_assignListener(mListener);\n			if (!items.empty()) sm->setItems(items);\n			return sm;\n		}\n\n		SelectMenu* createLongSelectMenu(TrayLocation trayLoc, const Ogre::String& name, const Ogre::DisplayString& caption,\n			Ogre::Real boxWidth, unsigned int maxItemsShown, const Ogre::StringVector& items = Ogre::StringVector())\n		{\n			return createLongSelectMenu(trayLoc, name, caption, 0, boxWidth, maxItemsShown, items);\n		}\n\n		Label* createLabel(TrayLocation trayLoc, const Ogre::String& name, const Ogre::DisplayString& caption, Ogre::Real width = 0)\n		{\n			Label* l = new Label(name, caption, width);\n			moveWidgetToTray(l, trayLoc);\n			l->_assignListener(mListener);\n			return l;\n		}\n\n		Separator* createSeparator(TrayLocation trayLoc, const Ogre::String& name, Ogre::Real width = 0)\n		{\n			Separator* s = new Separator(name, width);\n			moveWidgetToTray(s, trayLoc);\n			return s;\n		}\n\n		Slider* createThickSlider(TrayLocation trayLoc, const Ogre::String& name, const Ogre::DisplayString& caption,\n			Ogre::Real width, Ogre::Real valueBoxWidth, Ogre::Real minValue, Ogre::Real maxValue, unsigned int snaps)\n		{\n			Slider* s = new Slider(name, caption, width, 0, valueBoxWidth, minValue, maxValue, snaps);\n			moveWidgetToTray(s, trayLoc);\n			s->_assignListener(mListener);\n			return s;\n		}\n\n		Slider* createLongSlider(TrayLocation trayLoc, const Ogre::String& name, const Ogre::DisplayString& caption, Ogre::Real width,\n			Ogre::Real trackWidth, Ogre::Real valueBoxWidth, Ogre::Real minValue, Ogre::Real maxValue, unsigned int snaps)\n		{\n			if (trackWidth <= 0) trackWidth = 1;\n			Slider* s = new Slider(name, caption, width, trackWidth, valueBoxWidth, minValue, maxValue, snaps);\n			moveWidgetToTray(s, trayLoc);\n			s->_assignListener(mListener);\n			return s;\n		}\n\n		Slider* createLongSlider(TrayLocation trayLoc, const Ogre::String& name, const Ogre::DisplayString& caption,\n			Ogre::Real trackWidth, Ogre::Real valueBoxWidth, Ogre::Real minValue, Ogre::Real maxValue, unsigned int snaps)\n		{\n			return createLongSlider(trayLoc, name, caption, 0, trackWidth, valueBoxWidth, minValue, maxValue, snaps);\n		}\n\n		ParamsPanel* createParamsPanel(TrayLocation trayLoc, const Ogre::String& name, Ogre::Real width, unsigned int lines)\n		{\n			ParamsPanel* pp = new ParamsPanel(name, width, lines);\n			moveWidgetToTray(pp, trayLoc);\n			return pp;\n		}\n\n		ParamsPanel* createParamsPanel(TrayLocation trayLoc, const Ogre::String& name, Ogre::Real width,\n			const Ogre::StringVector& paramNames)\n		{\n			ParamsPanel* pp = new ParamsPanel(name, width, paramNames.size());\n			pp->setAllParamNames(paramNames);\n			moveWidgetToTray(pp, trayLoc);\n			return pp;\n		}\n\n		CheckBox* createCheckBox(TrayLocation trayLoc, const Ogre::String& name, const Ogre::DisplayString& caption,\n			Ogre::Real width = 0)\n		{\n			CheckBox* cb = new CheckBox(name, caption, width);\n			moveWidgetToTray(cb, trayLoc);\n			cb->_assignListener(mListener);\n			return cb;\n		}\n\n		DecorWidget* createDecorWidget(TrayLocation trayLoc, const Ogre::String& name, const Ogre::String& templateName)\n		{\n			DecorWidget* dw = new DecorWidget(name, templateName);\n			moveWidgetToTray(dw, trayLoc);\n			return dw;\n		}\n\n		ProgressBar* createProgressBar(TrayLocation trayLoc, const Ogre::String& name, const Ogre::DisplayString& caption,\n			Ogre::Real width, Ogre::Real commentBoxWidth)\n		{\n			ProgressBar* pb = new ProgressBar(name, caption, width, commentBoxWidth);\n			moveWidgetToTray(pb, trayLoc);\n			return pb;\n		}\n\n		/*-----------------------------------------------------------------------------\n		| Shows frame statistics widget set in the specified location.\n		-----------------------------------------------------------------------------*/\n		void showFrameStats(TrayLocation trayLoc, int place = -1)\n		{\n			if (!areFrameStatsVisible())\n			{\n				Ogre::StringVector stats;\n				stats.push_back(\"Average FPS\");\n				stats.push_back(\"Best FPS\");\n				stats.push_back(\"Worst FPS\");\n				stats.push_back(\"Triangles\");\n				stats.push_back(\"Batches\");\n\n				mFpsLabel = createLabel(TL_NONE, mName + \"/FpsLabel\", \"FPS:\", 180);\n				mFpsLabel->_assignListener(this);\n				mStatsPanel = createParamsPanel(TL_NONE, mName + \"/StatsPanel\", 180, stats);\n			}\n\n			moveWidgetToTray(mFpsLabel, trayLoc, place);\n			moveWidgetToTray(mStatsPanel, trayLoc, locateWidgetInTray(mFpsLabel) + 1);\n		}\n\n		/*-----------------------------------------------------------------------------\n		| Hides frame statistics widget set.\n		-----------------------------------------------------------------------------*/\n		void hideFrameStats()\n		{\n			if (areFrameStatsVisible())\n			{\n				destroyWidget(mFpsLabel);\n				destroyWidget(mStatsPanel);\n				mFpsLabel = 0;\n				mStatsPanel = 0;\n			}\n		}\n\n		bool areFrameStatsVisible()\n		{\n			return mFpsLabel != 0;\n		}\n\n		/*-----------------------------------------------------------------------------\n		| Toggles visibility of advanced statistics.\n		-----------------------------------------------------------------------------*/\n		void toggleAdvancedFrameStats()\n		{\n			if (mFpsLabel) labelHit(mFpsLabel);\n		}\n\n		/*-----------------------------------------------------------------------------\n		| Shows logo in the specified location.\n		-----------------------------------------------------------------------------*/\n		void showLogo(TrayLocation trayLoc, int place = -1)\n		{\n			if (!isLogoVisible()) mLogo = createDecorWidget(TL_NONE, mName + \"/Logo\", \"SdkTrays/Logo\");\n			moveWidgetToTray(mLogo, trayLoc, place);\n		}\n\n		void hideLogo()\n		{\n			if (isLogoVisible())\n			{\n				destroyWidget(mLogo);\n				mLogo = 0;\n			}\n		}\n\n		bool isLogoVisible()\n		{\n			return mLogo != 0;\n		}\n\n		/*-----------------------------------------------------------------------------\n		| Shows loading bar. Also takes job settings: the number of resource groups\n		| to be initialised, the number of resource groups to be loaded, and the\n		| proportion of the job that will be taken up by initialisation. Usually,\n		| script parsing takes up most time, so the default value is 0.7.\n		-----------------------------------------------------------------------------*/\n		void showLoadingBar(unsigned int numGroupsInit = 1, unsigned int numGroupsLoad = 1,\n			Ogre::Real initProportion = 0.7)\n		{\n			if (mDialog) closeDialog();\n			if (mLoadBar) hideLoadingBar();\n\n			mLoadBar = new ProgressBar(mName + \"/LoadingBar\", \"Loading...\", 400, 308);\n			Ogre::OverlayElement* e = mLoadBar->getOverlayElement();\n			mDialogShade->addChild(e);\n			e->setVerticalAlignment(Ogre::GVA_CENTER);\n			e->setLeft(-(e->getWidth() / 2));\n			e->setTop(-(e->getHeight() / 2));\n\n			Ogre::ResourceGroupManager::getSingleton().addResourceGroupListener(this);\n			mCursorWasVisible = isCursorVisible();\n			hideCursor();\n			mDialogShade->show();\n\n			// calculate the proportion of job required to init/load one group\n\n			if (numGroupsInit == 0 && numGroupsLoad != 0)\n			{\n				mGroupInitProportion = 0;\n				mGroupLoadProportion = 1;\n			}\n			else if (numGroupsLoad == 0 && numGroupsInit != 0)\n			{\n				mGroupLoadProportion = 0;\n				if (numGroupsInit != 0) mGroupInitProportion = 1;\n			}\n			else if (numGroupsInit == 0 && numGroupsLoad == 0)\n			{\n				mGroupInitProportion = 0;\n				mGroupLoadProportion = 0;\n			}\n			else\n			{\n				mGroupInitProportion = initProportion / numGroupsInit;\n				mGroupLoadProportion = (1 - initProportion) / numGroupsLoad;\n			}\n		}\n\n		void hideLoadingBar()\n		{\n			if (mLoadBar)\n			{\n				mLoadBar->cleanup();\n				delete mLoadBar;\n				mLoadBar = 0;\n\n				Ogre::ResourceGroupManager::getSingleton().removeResourceGroupListener(this);\n				if (mCursorWasVisible) showCursor();\n				mDialogShade->hide();\n			}\n		}\n\n		bool isLoadingBarVisible()\n		{\n			return mLoadBar != 0;\n		}\n\n		/*-----------------------------------------------------------------------------\n		| Pops up a message dialog with an OK button.\n		-----------------------------------------------------------------------------*/\n		void showOkDialog(const Ogre::DisplayString& caption, const Ogre::DisplayString& message)\n		{\n			if (mLoadBar) hideLoadingBar();\n\n			Ogre::OverlayElement* e;\n\n			if (mDialog)\n			{\n				mDialog->setCaption(caption);\n				mDialog->setText(message);\n\n				if (mOk) return;\n				else\n				{\n					mYes->cleanup();\n					mNo->cleanup();\n					delete mYes;\n					delete mNo;\n					mYes = 0;\n					mNo = 0;\n				}\n			}\n			else\n			{\n				// give widgets a chance to reset in case they're in the middle of something\n				for (unsigned int i = 0; i < 10; i++)\n				{\n					for (unsigned int j = 0; j < mWidgets[i].size(); j++)\n					{\n						mWidgets[i][j]->_focusLost();\n					}\n				}\n\n				mDialogShade->show();\n\n				mDialog = new TextBox(mName + \"/DialogBox\", caption, 300, 208);\n				mDialog->setText(message);\n				e = mDialog->getOverlayElement();\n				mDialogShade->addChild(e);\n				e->setVerticalAlignment(Ogre::GVA_CENTER);\n				e->setLeft(-(e->getWidth() / 2));\n				e->setTop(-(e->getHeight() / 2));\n\n				mCursorWasVisible = isCursorVisible();\n				showCursor();\n			}\n\n			mOk = new Button(mName + \"/OkButton\", \"OK\", 60);\n			mOk->_assignListener(this);\n			e = mOk->getOverlayElement();\n			mDialogShade->addChild(e);\n			e->setVerticalAlignment(Ogre::GVA_CENTER);\n			e->setLeft(-(e->getWidth() / 2));\n			e->setTop(mDialog->getOverlayElement()->getTop() + mDialog->getOverlayElement()->getHeight() + 5);\n		}\n\n		/*-----------------------------------------------------------------------------\n		| Pops up a question dialog with Yes and No buttons.\n		-----------------------------------------------------------------------------*/\n		void showYesNoDialog(const Ogre::DisplayString& caption, const Ogre::DisplayString& question)\n		{\n			if (mLoadBar) hideLoadingBar();\n\n			Ogre::OverlayElement* e;\n\n			if (mDialog)\n			{\n				mDialog->setCaption(caption);\n				mDialog->setText(question);\n\n				if (mOk)\n				{\n					mOk->cleanup();\n					delete mOk;\n					mOk = 0;\n				}\n				else return;\n			}\n			else\n			{\n				// give widgets a chance to reset in case they're in the middle of something\n				for (unsigned int i = 0; i < 10; i++)\n				{\n					for (unsigned int j = 0; j < mWidgets[i].size(); j++)\n					{\n						mWidgets[i][j]->_focusLost();\n					}\n				}\n\n				mDialogShade->show();\n\n				mDialog = new TextBox(mName + \"/DialogBox\", caption, 300, 208);\n				mDialog->setText(question);\n				e = mDialog->getOverlayElement();\n				mDialogShade->addChild(e);\n				e->setVerticalAlignment(Ogre::GVA_CENTER);\n				e->setLeft(-(e->getWidth() / 2));\n				e->setTop(-(e->getHeight() / 2));\n\n				mCursorWasVisible = isCursorVisible();\n				showCursor();\n			}\n\n			mYes = new Button(mName + \"/YesButton\", \"Yes\", 58);\n			mYes->_assignListener(this);\n			e = mYes->getOverlayElement();\n			mDialogShade->addChild(e);\n			e->setVerticalAlignment(Ogre::GVA_CENTER);\n			e->setLeft(-(e->getWidth() + 2));\n			e->setTop(mDialog->getOverlayElement()->getTop() + mDialog->getOverlayElement()->getHeight() + 5);\n\n			mNo = new Button(mName + \"/NoButton\", \"No\", 50);\n			mNo->_assignListener(this);\n			e = mNo->getOverlayElement();\n			mDialogShade->addChild(e);\n			e->setVerticalAlignment(Ogre::GVA_CENTER);\n			e->setLeft(3);\n			e->setTop(mDialog->getOverlayElement()->getTop() + mDialog->getOverlayElement()->getHeight() + 5);\n		}\n\n		/*-----------------------------------------------------------------------------\n		| Hides whatever dialog is currently showing.\n		-----------------------------------------------------------------------------*/\n		void closeDialog()\n		{\n			if (mDialog)\n			{\n				if (mOk)\n				{\n					mOk->cleanup();\n					delete mOk;\n					mOk = 0;\n				}\n				else\n				{\n					mYes->cleanup();\n					mNo->cleanup();\n					delete mYes;\n					delete mNo;\n					mYes = 0;\n					mNo = 0;\n				}\n\n				mDialogShade->hide();\n				mDialog->cleanup();\n				delete mDialog;\n				mDialog = 0;\n\n				if (!mCursorWasVisible) hideCursor();\n			}\n		}\n\n		/*-----------------------------------------------------------------------------\n		| Determines if any dialog is currently visible.\n		-----------------------------------------------------------------------------*/\n		bool isDialogVisible()\n		{\n			return mDialog != 0;\n		}\n\n		/*-----------------------------------------------------------------------------\n		| Gets a widget from a tray by place.\n		-----------------------------------------------------------------------------*/\n		Widget* getWidget(TrayLocation trayLoc, unsigned int place)\n		{\n			if (place < mWidgets[trayLoc].size()) return mWidgets[trayLoc][place];\n			return 0;\n		}\n\n		/*-----------------------------------------------------------------------------\n		| Gets a widget from a tray by name.\n		-----------------------------------------------------------------------------*/\n		Widget* getWidget(TrayLocation trayLoc, const Ogre::String& name)\n		{\n			for (unsigned int i = 0; i < mWidgets[trayLoc].size(); i++)\n			{\n				if (mWidgets[trayLoc][i]->getName() == name) return mWidgets[trayLoc][i];\n			}\n			return 0;\n		}\n\n		/*-----------------------------------------------------------------------------\n		| Gets a widget by name.\n		-----------------------------------------------------------------------------*/\n		Widget* getWidget(const Ogre::String& name)\n		{\n			for (unsigned int i = 0; i < 10; i++)\n			{\n				for (unsigned int j = 0; j < mWidgets[i].size(); j++)\n				{\n					if (mWidgets[i][j]->getName() == name) return mWidgets[i][j];\n				}\n			}\n			return 0;\n		}\n\n		/*-----------------------------------------------------------------------------\n		| Gets the number of widgets in total.\n		-----------------------------------------------------------------------------*/\n		unsigned int getNumWidgets()\n		{\n			unsigned int total = 0;\n\n			for (unsigned int i = 0; i < 10; i++)\n			{\n				total += mWidgets[i].size();\n			}\n\n			return total;\n		}\n\n		/*-----------------------------------------------------------------------------\n		| Gets the number of widgets in a tray.\n		-----------------------------------------------------------------------------*/\n		unsigned int getNumWidgets(TrayLocation trayLoc)\n		{\n			return mWidgets[trayLoc].size();\n		}\n\n		/*-----------------------------------------------------------------------------\n		| Gets all the widgets of a specific tray.\n		-----------------------------------------------------------------------------*/\n		WidgetIterator getWidgetIterator(TrayLocation trayLoc)\n		{\n			return WidgetIterator(mWidgets[trayLoc].begin(), mWidgets[trayLoc].end());\n		}\n\n		/*-----------------------------------------------------------------------------\n		| Gets a widget's position in its tray.\n		-----------------------------------------------------------------------------*/\n		int locateWidgetInTray(Widget* widget)\n		{\n			for (unsigned int i = 0; i < mWidgets[widget->getTrayLocation()].size(); i++)\n			{\n				if (mWidgets[widget->getTrayLocation()][i] == widget) return i;\n			}\n			return -1;\n		}\n\n		/*-----------------------------------------------------------------------------\n		| Destroys a widget.\n		-----------------------------------------------------------------------------*/\n		void destroyWidget(Widget* widget)\n		{\n			if (!widget) OGRE_EXCEPT(Ogre::Exception::ERR_ITEM_NOT_FOUND, \"Widget does not exist.\", \"TrayManager::destroyWidget\");\n\n			// in case special widgets are destroyed manually, set them to 0\n			if (widget == mLogo) mLogo = 0;\n			else if (widget == mStatsPanel) mStatsPanel = 0;\n			else if (widget == mFpsLabel) mFpsLabel = 0;\n\n			mTrays[widget->getTrayLocation()]->removeChild(widget->getName());\n\n			WidgetList& wList = mWidgets[widget->getTrayLocation()];\n			wList.erase(std::find(wList.begin(), wList.end(), widget));\n			if (widget == mExpandedMenu) setExpandedMenu(0);\n\n			widget->cleanup();\n\n			mWidgetDeathRow.push_back(widget);\n\n			adjustTrays();\n		}\n\n		void destroyWidget(TrayLocation trayLoc, unsigned int place)\n		{\n			destroyWidget(getWidget(trayLoc, place));\n		}\n\n		void destroyWidget(TrayLocation trayLoc, const Ogre::String& name)\n		{\n			destroyWidget(getWidget(trayLoc, name));\n		}\n\n		void destroyWidget(const Ogre::String& name)\n		{\n			destroyWidget(getWidget(name));\n		}\n\n		/*-----------------------------------------------------------------------------\n		| Destroys all widgets in a tray.\n		-----------------------------------------------------------------------------*/\n		void destroyAllWidgetsInTray(TrayLocation trayLoc)\n		{\n			while (!mWidgets[trayLoc].empty()) destroyWidget(mWidgets[trayLoc][0]);\n		}\n\n		/*-----------------------------------------------------------------------------\n		| Destroys all widgets.\n		-----------------------------------------------------------------------------*/\n		void destroyAllWidgets()\n		{\n			for (unsigned int i = 0; i < 10; i++)  // destroy every widget in every tray (including null tray)\n			{\n				destroyAllWidgetsInTray((TrayLocation)i);\n			}\n		}\n\n		/*-----------------------------------------------------------------------------\n		| Adds a widget to a specified tray.\n		-----------------------------------------------------------------------------*/\n		void moveWidgetToTray(Widget* widget, TrayLocation trayLoc, int place = -1)\n		{\n			if (!widget) OGRE_EXCEPT(Ogre::Exception::ERR_ITEM_NOT_FOUND, \"Widget does not exist.\", \"TrayManager::moveWidgetToTray\");\n\n			// remove widget from old tray\n			WidgetList& wList = mWidgets[widget->getTrayLocation()];\n			WidgetList::iterator it = std::find(wList.begin(), wList.end(), widget);\n			if (it != wList.end())\n			{\n				wList.erase(it);\n				mTrays[widget->getTrayLocation()]->removeChild(widget->getName());\n			}\n\n			// insert widget into new tray at given position, or at the end if unspecified or invalid\n			if (place == -1 || place > (int)mWidgets[trayLoc].size()) place = mWidgets[trayLoc].size();\n			mWidgets[trayLoc].insert(mWidgets[trayLoc].begin() + place, widget);\n			mTrays[trayLoc]->addChild(widget->getOverlayElement());\n\n			widget->getOverlayElement()->setHorizontalAlignment(mTrayWidgetAlign[trayLoc]);\n			\n			// adjust trays if necessary\n			if (widget->getTrayLocation() != TL_NONE || trayLoc != TL_NONE) adjustTrays();\n\n			widget->_assignToTray(trayLoc);\n		}\n\n		void moveWidgetToTray(const Ogre::String& name, TrayLocation trayLoc, unsigned int place = -1)\n		{\n			moveWidgetToTray(getWidget(name), trayLoc, place);\n		}\n\n		void moveWidgetToTray(TrayLocation currentTrayLoc, const Ogre::String& name, TrayLocation targetTrayLoc,\n			int place = -1)\n		{\n			moveWidgetToTray(getWidget(currentTrayLoc, name), targetTrayLoc, place);\n		}\n\n		void moveWidgetToTray(TrayLocation currentTrayLoc, unsigned int currentPlace, TrayLocation targetTrayLoc,\n			int targetPlace = -1)\n		{\n			moveWidgetToTray(getWidget(currentTrayLoc, currentPlace), targetTrayLoc, targetPlace);\n		}\n\n		/*-----------------------------------------------------------------------------\n		| Removes a widget from its tray. Same as moving it to the null tray.\n		-----------------------------------------------------------------------------*/\n		void removeWidgetFromTray(Widget* widget)\n		{\n			moveWidgetToTray(widget, TL_NONE);\n		}\n\n		void removeWidgetFromTray(const Ogre::String& name)\n		{\n			removeWidgetFromTray(getWidget(name));\n		}\n\n		void removeWidgetFromTray(TrayLocation trayLoc, const Ogre::String& name)\n		{\n			removeWidgetFromTray(getWidget(trayLoc, name));\n		}\n\n		void removeWidgetFromTray(TrayLocation trayLoc, int place)\n		{\n			removeWidgetFromTray(getWidget(trayLoc, place));\n		}\n\n		/*-----------------------------------------------------------------------------\n		| Removes all widgets from a widget tray.\n		-----------------------------------------------------------------------------*/\n		void clearTray(TrayLocation trayLoc)\n		{\n			if (trayLoc == TL_NONE) return;      // can't clear the null tray\n\n			while (!mWidgets[trayLoc].empty())   // remove every widget from given tray\n			{\n				removeWidgetFromTray(mWidgets[trayLoc][0]);\n			}\n		}\n\n		/*-----------------------------------------------------------------------------\n		| Removes all widgets from all widget trays.\n		-----------------------------------------------------------------------------*/\n		void clearAllTrays()\n		{\n			for (unsigned int i = 0; i < 9; i++)\n			{\n				clearTray((TrayLocation)i);\n			}\n		}\n\n		/*-----------------------------------------------------------------------------\n		| Process frame events. Updates frame statistics widget set and deletes\n		| all widgets queued for destruction.\n		-----------------------------------------------------------------------------*/\n		bool frameRenderingQueued(const Ogre::FrameEvent& evt)\n		{\n			for (unsigned int i = 0; i < mWidgetDeathRow.size(); i++)\n			{\n				delete mWidgetDeathRow[i];\n			}\n			mWidgetDeathRow.clear();\n\n\n            unsigned long currentTime = mTimer->getMilliseconds();\n			if (areFrameStatsVisible() && currentTime - mLastStatUpdateTime > 250)\n			{\n                Ogre::RenderTarget::FrameStats stats = mWindow->getStatistics();\n\n                mLastStatUpdateTime = currentTime;\n\n				Ogre::String s(\"FPS: \");\n				s += Ogre::StringConverter::toString((int)stats.lastFPS);\n				\n				for (int i = s.length() - 5; i > 5; i -= 3) { s.insert(i, 1, ','); }\n				mFpsLabel->setCaption(s);\n\n				if (mStatsPanel->getOverlayElement()->isVisible())\n				{\n					Ogre::StringVector values;\n					std::ostringstream oss;\n					\n					oss.str(\"\");\n					oss << std::fixed << std::setprecision(1) << stats.avgFPS;\n					Ogre::String str = oss.str();\n					for (int i = str.length() - 5; i > 0; i -= 3) { str.insert(i, 1, ','); }\n					values.push_back(str);\n\n					oss.str(\"\");\n					oss << std::fixed << std::setprecision(1) << stats.bestFPS;\n					str = oss.str();\n					for (int i = str.length() - 5; i > 0; i -= 3) { str.insert(i, 1, ','); }\n					values.push_back(str);\n\n					oss.str(\"\");\n					oss << std::fixed << std::setprecision(1) << stats.worstFPS;\n					str = oss.str();\n					for (int i = str.length() - 5; i > 0; i -= 3) { str.insert(i, 1, ','); }\n					values.push_back(str);\n\n					str = Ogre::StringConverter::toString(stats.triangleCount);\n					for (int i = str.length() - 3; i > 0; i -= 3) { str.insert(i, 1, ','); }\n					values.push_back(str);\n\n					str = Ogre::StringConverter::toString(stats.batchCount);\n					for (int i = str.length() - 3; i > 0; i -= 3) { str.insert(i, 1, ','); }\n					values.push_back(str);\n\n					mStatsPanel->setAllParamValues(values);\n				}\n			}\n\n			return true;\n		}\n\n        void windowUpdate()\n        {\n#if OGRE_PLATFORM != OGRE_PLATFORM_APPLE_IOS && OGRE_PLATFORM != OGRE_PLATFORM_NACL\n            mWindow->update();\n#endif\n        }\n\n		void resourceGroupScriptingStarted(const Ogre::String& groupName, size_t scriptCount)\n		{\n			mLoadInc = mGroupInitProportion / scriptCount;\n			mLoadBar->setCaption(\"Parsing...\");\n			windowUpdate();\n		}\n\n		void scriptParseStarted(const Ogre::String& scriptName, bool& skipThisScript)\n		{\n			mLoadBar->setComment(scriptName);\n			windowUpdate();\n		}\n\n		void scriptParseEnded(const Ogre::String& scriptName, bool skipped)\n		{\n			mLoadBar->setProgress(mLoadBar->getProgress() + mLoadInc);\n			windowUpdate();\n		}\n\n		void resourceGroupScriptingEnded(const Ogre::String& groupName) {}\n\n		void resourceGroupLoadStarted(const Ogre::String& groupName, size_t resourceCount)\n		{\n			mLoadInc = mGroupLoadProportion / resourceCount;\n			mLoadBar->setCaption(\"Loading...\");\n			windowUpdate();\n		}\n\n		void resourceLoadStarted(const Ogre::ResourcePtr& resource)\n		{\n			mLoadBar->setComment(resource->getName());\n			windowUpdate();\n		}\n\n		void resourceLoadEnded()\n		{\n			mLoadBar->setProgress(mLoadBar->getProgress() + mLoadInc);\n			windowUpdate();\n		}\n\n		void worldGeometryStageStarted(const Ogre::String& description)\n		{\n			mLoadBar->setComment(description);\n			windowUpdate();\n		}\n\n		void worldGeometryStageEnded()\n		{\n			mLoadBar->setProgress(mLoadBar->getProgress() + mLoadInc);\n			windowUpdate();\n		}\n\n		void resourceGroupLoadEnded(const Ogre::String& groupName) {}\n\n		/*-----------------------------------------------------------------------------\n		| Toggles visibility of advanced statistics.\n		-----------------------------------------------------------------------------*/\n		void labelHit(Label* label)\n		{\n			if (mStatsPanel->getOverlayElement()->isVisible())\n			{\n				mStatsPanel->getOverlayElement()->hide();\n				mFpsLabel->getOverlayElement()->setWidth(150);\n				removeWidgetFromTray(mStatsPanel);\n			}\n			else\n			{\n				mStatsPanel->getOverlayElement()->show();\n				mFpsLabel->getOverlayElement()->setWidth(180);\n				moveWidgetToTray(mStatsPanel, mFpsLabel->getTrayLocation(), locateWidgetInTray(mFpsLabel) + 1);\n			}\n		}\n\n		/*-----------------------------------------------------------------------------\n		| Destroys dialog widgets, notifies listener, and ends high priority session.\n		-----------------------------------------------------------------------------*/\n		void buttonHit(Button* button)\n		{\n			if (mListener)\n			{\n				if (button == mOk) mListener->okDialogClosed(mDialog->getText());\n				else mListener->yesNoDialogClosed(mDialog->getText(), button == mYes);\n			}\n			closeDialog();\n		}\n\n		/*-----------------------------------------------------------------------------\n		| Processes mouse button down events. Returns true if the event was\n		| consumed and should not be passed on to other handlers.\n		-----------------------------------------------------------------------------*/\n#if (OGRE_PLATFORM == OGRE_PLATFORM_APPLE_IOS) || (OGRE_PLATFORM == OGRE_PLATFORM_ANDROID)\n		bool injectMouseDown(const OIS::MultiTouchEvent& evt)\n#else\n		bool injectMouseDown(const OIS::MouseEvent& evt, OIS::MouseButtonID id)\n#endif\n		{\n#if (OGRE_PLATFORM != OGRE_PLATFORM_APPLE_IOS) && (OGRE_PLATFORM != OGRE_PLATFORM_ANDROID)\n			// only process left button when stuff is visible\n			if (!mCursorLayer->isVisible() || id != OIS::MB_Left) return false;\n#else\n            // only process touches when stuff is visible\n			if (!mCursorLayer->isVisible()) return false;\n#endif\n			Ogre::Vector2 cursorPos(mCursor->getLeft(), mCursor->getTop());\n\n			mTrayDrag = false;\n\n			if (mExpandedMenu)   // only check top priority widget until it passes on\n			{\n				mExpandedMenu->_cursorPressed(cursorPos);\n				if (!mExpandedMenu->isExpanded()) setExpandedMenu(0);\n				return true;\n			}\n\n			if (mDialog)   // only check top priority widget until it passes on\n			{\n				mDialog->_cursorPressed(cursorPos);\n				if (mOk) mOk->_cursorPressed(cursorPos);\n				else\n				{\n					mYes->_cursorPressed(cursorPos);\n					mNo->_cursorPressed(cursorPos);\n				}\n				return true;\n			}\n\n			for (unsigned int i = 0; i < 9; i++)   // check if mouse is over a non-null tray\n			{\n				if (mTrays[i]->isVisible() && Widget::isCursorOver(mTrays[i], cursorPos, 2))\n				{\n					mTrayDrag = true;   // initiate a drag that originates in a tray\n					break;\n				}\n			}\n\n			for (unsigned int i = 0; i < mWidgets[9].size(); i++)  // check if mouse is over a non-null tray's widgets\n			{\n				if (mWidgets[9][i]->getOverlayElement()->isVisible() &&\n					Widget::isCursorOver(mWidgets[9][i]->getOverlayElement(), cursorPos))\n				{\n					mTrayDrag = true;   // initiate a drag that originates in a tray\n					break;\n				}\n			}\n\n			if (!mTrayDrag) return false;   // don't process if mouse press is not in tray\n\n			for (unsigned int i = 0; i < 10; i++)\n			{\n				if (!mTrays[i]->isVisible()) continue;\n\n				for (unsigned int j = 0; j < mWidgets[i].size(); j++)\n				{\n					Widget* w = mWidgets[i][j];\n					if (!w->getOverlayElement()->isVisible()) continue;\n					w->_cursorPressed(cursorPos);    // send event to widget\n\n					SelectMenu* m = dynamic_cast<SelectMenu*>(w);\n					if (m && m->isExpanded())       // a menu has begun a top priority session\n					{\n						setExpandedMenu(m);\n						return true;\n					}\n				}\n			}\n\n			return true;   // a tray click is not to be handled by another party\n		}\n\n		/*-----------------------------------------------------------------------------\n		| Processes mouse button up events. Returns true if the event was\n		| consumed and should not be passed on to other handlers.\n		-----------------------------------------------------------------------------*/\n#if (OGRE_PLATFORM == OGRE_PLATFORM_APPLE_IOS) || (OGRE_PLATFORM == OGRE_PLATFORM_ANDROID)\n		bool injectMouseUp(const OIS::MultiTouchEvent& evt)\n#else\n		bool injectMouseUp(const OIS::MouseEvent& evt, OIS::MouseButtonID id)\n#endif\n		{\n#if (OGRE_PLATFORM != OGRE_PLATFORM_APPLE_IOS) && (OGRE_PLATFORM != OGRE_PLATFORM_ANDROID)\n			// only process left button when stuff is visible\n			if (!mCursorLayer->isVisible() || id != OIS::MB_Left) return false;\n#else\n            // only process touches when stuff is visible\n			if (!mCursorLayer->isVisible()) return false;\n#endif\n			Ogre::Vector2 cursorPos(mCursor->getLeft(), mCursor->getTop());\n\n			if (mExpandedMenu)   // only check top priority widget until it passes on\n			{\n				mExpandedMenu->_cursorReleased(cursorPos);\n				return true;\n			}\n\n			if (mDialog)   // only check top priority widget until it passes on\n			{\n				mDialog->_cursorReleased(cursorPos);\n				if (mOk) mOk->_cursorReleased(cursorPos);\n				else\n				{\n					mYes->_cursorReleased(cursorPos);\n					// very important to check if second button still exists, because first button could've closed the popup\n					if (mNo) mNo->_cursorReleased(cursorPos); \n				}\n				return true;\n			}\n\n			if (!mTrayDrag) return false;    // this click did not originate in a tray, so don't process\n\n			Widget* w;\n\n			for (unsigned int i = 0; i < 10; i++)\n			{\n				if (!mTrays[i]->isVisible()) continue;\n\n				for (unsigned int j = 0; j < mWidgets[i].size(); j++)\n				{\n					w = mWidgets[i][j];\n					if (!w->getOverlayElement()->isVisible()) continue;\n					w->_cursorReleased(cursorPos);    // send event to widget\n				}\n			}\n\n			mTrayDrag = false;   // stop this drag\n			return true;         // this click did originate in this tray, so don't pass it on\n		}\n\n		/*-----------------------------------------------------------------------------\n		| Updates cursor position. Returns true if the event was\n		| consumed and should not be passed on to other handlers.\n		-----------------------------------------------------------------------------*/\n#if (OGRE_PLATFORM == OGRE_PLATFORM_APPLE_IOS) || (OGRE_PLATFORM == OGRE_PLATFORM_ANDROID)\n		bool injectMouseMove(const OIS::MultiTouchEvent& evt)\n#else\n		bool injectMouseMove(const OIS::MouseEvent& evt)\n#endif\n		{\n			if (!mCursorLayer->isVisible()) return false;   // don't process if cursor layer is invisible\n\n            Ogre::Vector2 cursorPos(evt.state.X.abs, evt.state.Y.abs);\n			mCursor->setPosition(cursorPos.x, cursorPos.y);\n\n			if (mExpandedMenu)   // only check top priority widget until it passes on\n			{\n				mExpandedMenu->_cursorMoved(cursorPos);\n				return true;\n			}\n\n			if (mDialog)   // only check top priority widget until it passes on\n			{\n				mDialog->_cursorMoved(cursorPos);\n				if (mOk) mOk->_cursorMoved(cursorPos);\n				else\n				{\n					mYes->_cursorMoved(cursorPos);\n					mNo->_cursorMoved(cursorPos);\n				}\n				return true;\n			}\n\n			Widget* w;\n\n			for (unsigned int i = 0; i < 10; i++)\n			{\n				if (!mTrays[i]->isVisible()) continue;\n\n				for (unsigned int j = 0; j < mWidgets[i].size(); j++)\n				{\n					w = mWidgets[i][j];\n					if (!w->getOverlayElement()->isVisible()) continue;\n					w->_cursorMoved(cursorPos);    // send event to widget\n				}\n			}\n\n			if (mTrayDrag) return true;  // don't pass this event on if we're in the middle of a drag\n			return false;\n		}\n\n    protected:\n\n		/*-----------------------------------------------------------------------------\n		| Internal method to prioritise / deprioritise expanded menus.\n		-----------------------------------------------------------------------------*/\n		void setExpandedMenu(SelectMenu* m)\n		{\n			if (!mExpandedMenu && m)\n			{\n				Ogre::OverlayContainer* c = (Ogre::OverlayContainer*)m->getOverlayElement();\n				Ogre::OverlayContainer* eb = (Ogre::OverlayContainer*)c->getChild(m->getName() + \"/MenuExpandedBox\");\n				eb->_update();\n				eb->setPosition\n					((unsigned int)(eb->_getDerivedLeft() * Ogre::OverlayManager::getSingleton().getViewportWidth()),\n					(unsigned int)(eb->_getDerivedTop() * Ogre::OverlayManager::getSingleton().getViewportHeight()));\n				c->removeChild(eb->getName());\n				mPriorityLayer->add2D(eb);\n			}\n			else if(mExpandedMenu && !m)\n			{\n				Ogre::OverlayContainer* eb = mPriorityLayer->getChild(mExpandedMenu->getName() + \"/MenuExpandedBox\");\n				mPriorityLayer->remove2D(eb);\n				((Ogre::OverlayContainer*)mExpandedMenu->getOverlayElement())->addChild(eb);\n			}\n\n			mExpandedMenu = m;\n		}\n\n		Ogre::String mName;                   // name of this tray system\n		Ogre::RenderWindow* mWindow;          // render window\n#if (OGRE_PLATFORM == OGRE_PLATFORM_APPLE_IOS) || (OGRE_PLATFORM == OGRE_PLATFORM_ANDROID)\n		OIS::MultiTouch* mMouse;              // multitouch device\n#else\n		OIS::Mouse* mMouse;                   // mouse device\n#endif\n		Ogre::Overlay* mBackdropLayer;        // backdrop layer\n		Ogre::Overlay* mTraysLayer;           // widget layer\n		Ogre::Overlay* mPriorityLayer;        // top priority layer\n		Ogre::Overlay* mCursorLayer;          // cursor layer\n		Ogre::OverlayContainer* mBackdrop;    // backdrop\n		Ogre::OverlayContainer* mTrays[10];   // widget trays\n	    WidgetList mWidgets[10];              // widgets\n		WidgetList mWidgetDeathRow;           // widget queue for deletion\n		Ogre::OverlayContainer* mCursor;      // cursor\n		SdkTrayListener* mListener;           // tray listener\n		Ogre::Real mWidgetPadding;            // widget padding\n		Ogre::Real mWidgetSpacing;            // widget spacing\n		Ogre::Real mTrayPadding;              // tray padding\n		bool mTrayDrag;                       // a mouse press was initiated on a tray\n		SelectMenu* mExpandedMenu;            // top priority expanded menu widget\n		TextBox* mDialog;                     // top priority dialog widget\n		Ogre::OverlayContainer* mDialogShade; // top priority dialog shade\n		Button* mOk;                          // top priority OK button\n		Button* mYes;                         // top priority Yes button\n		Button* mNo;                          // top priority No button\n		bool mCursorWasVisible;               // cursor state before showing dialog\n		Label* mFpsLabel;                     // FPS label\n		ParamsPanel* mStatsPanel;             // frame stats panel\n		DecorWidget* mLogo;                   // logo\n		ProgressBar* mLoadBar;                // loading bar\n		Ogre::Real mGroupInitProportion;      // proportion of load job assigned to initialising one resource group\n		Ogre::Real mGroupLoadProportion;      // proportion of load job assigned to loading one resource group\n		Ogre::Real mLoadInc;                  // loading increment\n		Ogre::GuiHorizontalAlignment mTrayWidgetAlign[10];   // tray widget alignments\n        Ogre::Timer* mTimer;                  // Root::getSingleton().getTimer()\n        unsigned long mLastStatUpdateTime;    // The last time the stat text were updated\n\n    };\n}\n\n#endif\n",
			"file": "/usr/include/OGRE/Samples/Common/include/SdkTrays.h",
			"file_size": 103737,
			"file_write_time": 130723063837377448,
			"settings":
			{
				"buffer_size": 103737,
				"line_ending": "Unix"
			}
		}
	],
	"build_system": "",
	"build_system_choices":
	[
	],
	"build_varint": "",
	"command_palette":
	{
		"height": 400.0,
		"last_filter": "dif",
		"selected_items":
		[
			[
				"dif",
				"Git: Diff All Files"
			],
			[
				"packa",
				"Package Control: Install Package"
			],
			[
				"package",
				"Package Control: Install Package"
			],
			[
				"Snippet: ",
				"Snippet: #!/usr/bin/env"
			],
			[
				"pac",
				"PackageResourceViewer: Open Resource"
			],
			[
				"push",
				"Git: Push"
			],
			[
				"qui",
				"Git: Quick Commit"
			],
			[
				"ad",
				"Git: Add..."
			],
			[
				"add",
				"Git: Add..."
			],
			[
				"commi",
				"Git: Quick Commit"
			],
			[
				"comm",
				"Git: Quick Commit"
			],
			[
				"com",
				"Git: Quick Commit"
			],
			[
				"q",
				"Git: Quick Commit"
			],
			[
				"pa",
				"PackageResourceViewer: Extract Package"
			],
			[
				"insta",
				"Package Control: Install Package"
			],
			[
				"gutt",
				"GitGutter: Show Comparing Against"
			],
			[
				"gutter",
				"GitGutter: Compare Against Commit"
			]
		],
		"width": 601.0
	},
	"console":
	{
		"height": 139.0,
		"history":
		[
			"import urllib.request,os,hashlib; h = 'eb2297e1a458f27d836c04bb0cbaf282' + 'd0e7a3098092775ccb37ca9d6b2e4b7d'; pf = 'Package Control.sublime-package'; ipp = sublime.installed_packages_path(); urllib.request.install_opener( urllib.request.build_opener( urllib.request.ProxyHandler()) ); by = urllib.request.urlopen( 'http://packagecontrol.io/' + pf.replace(' ', '%20')).read(); dh = hashlib.sha256(by).hexdigest(); print('Error validating download (got %s instead of %s), please try manual install' % (dh, h)) if dh != h else open(os.path.join( ipp, pf), 'wb' ).write(by)"
		]
	},
	"distraction_free":
	{
		"menu_visible": true,
		"show_minimap": false,
		"show_open_files": false,
		"show_tabs": false,
		"side_bar_visible": false,
		"status_bar_visible": false
	},
	"expanded_folders":
	[
		"/home/unnar/catkin_ws/src/rosOgre",
		"/home/unnar/catkin_ws/src/rosOgre/dist",
		"/home/unnar/catkin_ws/src/rosOgre/dist/bin",
		"/home/unnar/catkin_ws/src/rosOgre/include",
		"/home/unnar/catkin_ws/src/rosOgre/include/triangulation",
		"/home/unnar/catkin_ws/src/rosOgre/parameters",
		"/home/unnar/catkin_ws/src/rosOgre/run_from",
		"/home/unnar/catkin_ws/src/rosOgre/src"
	],
	"file_history":
	[
		"/home/unnar/catkin_ws/src/rosOgre/src/BaseApplication.cpp",
		"/home/unnar/catkin_ws/src/rosOgre/rosOgre.launch",
		"/home/unnar/catkin_ws/src/rosOgre/CMakeLists.txt",
		"/home/unnar/catkin_ws/src/rosOgre/dist/bin/resources.cfg",
		"/usr/share/applications/pclviewer.desktop",
		"/home/unnar/catkin_ws/src/Metarooms/room_0/room.xml",
		"/home/unnar/catkin_ws/src/rosOgre/include/BaseApplication.h",
		"/home/unnar/catkin_ws/src/rosOgre/include/PCLfunctions/cloud_generation.h",
		"/home/unnar/catkin_ws/src/rosOgre/package.xml",
		"/home/unnar/.bash_aliases",
		"/home/unnar/catkin_ws/src/exx_wall_extraction/CMakeLists.txt",
		"/home/unnar/.config/sublime-text-3/Packages/User/Default (Linux).sublime-keymap",
		"/home/unnar/catkin_ws/src/exx_wall_extraction/include/triangulation/triangulation.h",
		"/home/unnar/.config/sublime-text-3/Packages/Default/Default (Linux).sublime-keymap",
		"/home/unnar/.config/sublime-text-3/Packages/Color Scheme - Default/Monokai.tmTheme",
		"/home/unnar/catkin_ws/src/rosOgre/run_from/resources.cfg",
		"/home/unnar/catkin_ws/src/rosOgre/run_from/plugins.cfg",
		"/home/unnar/catkin_ws/src/rosOgre/run_from/Ogre.log",
		"/home/unnar/catkin_ws/src/rosOgre/include/triangulation/triangulation.h",
		"/home/unnar/catkin_ws/src/rosOgre/include/triangulation/triangulation.cpp",
		"/home/unnar/catkin_ws/src/rosOgre/include/TutorialApplication.h",
		"/home/unnar/catkin_ws/src/rosOgre/dist/media/models/ogrehead.mesh",
		"/home/unnar/catkin_ws/src/rosOgre/dist/media/materials/scripts/Ogre.material",
		"/home/unnar/catkin_ws/src/rosOgre/dist/bin/plugins.cfg",
		"/home/unnar/catkin_ws/src/rosOgre/dist/bin/ogre.cfg",
		"/home/unnar/catkin_ws/src/rosOgre/dist/bin/mesh.vtk",
		"/home/unnar/catkin_ws/src/rosOgre/dist/bin/Ogre.log",
		"/home/unnar/catkin_ws/src/rosOgre/README.md",
		"/home/unnar/catkin_ws/src/rosOgre/Ogre.log",
		"/home/unnar/catkin_ws/src/exx_wall_extraction/include/compression/plane_concave_hull.h",
		"/home/unnar/catkin_ws/src/exx_wall_extraction/include/compression/cloud_triangulation.h",
		"/home/unnar/catkin_ws/src/exx_wall_extraction/src/plane_compression.cpp",
		"/home/unnar/catkin_ws/src/exx_wall_extraction/include/triangulation/triangulation.cpp",
		"/home/unnar/catkin_ws/src/exx_wall_extraction/include/compression/cloud_filtering.h",
		"/home/unnar/catkin_ws/src/exx_wall_extraction/include/compression/plane_extraction.h",
		"/home/unnar/catkin_ws/src/exx_wall_extraction/include/compression/compress_methods.h",
		"/home/unnar/catkin_ws/src/exx_wall_extraction/src/plane_test.cpp",
		"/home/unnar/catkin_ws/src/exx_wall_extraction/include/compression/plane_compression_node.h",
		"/home/unnar/catkin_ws/src/exx_wall_extraction/include/compression/plane_extraction_node.h",
		"/home/unnar/catkin_ws/src/exx_wall_extraction/include/compression/filtering.h",
		"/home/unnar/catkin_ws/src/exx_wall_extraction/include/exx_plane_extraction/compress_methods.h",
		"/home/unnar/catkin_ws/src/exx_wall_extraction/include/exx_plane_extraction/plane_extraction.h",
		"/home/unnar/.config/sublime-text-3/Packages/Alignment/Default (Linux).sublime-keymap",
		"/home/unnar/.config/sublime-text-3/Packages/Alignment/Base File.sublime-settings",
		"/home/unnar/.config/sublime-text-3/Packages/Theme - Spacegray/Spacegray Eighties.sublime-theme",
		"/home/unnar/.config/sublime-text-3/Packages/Color Scheme - Default/LAZY.tmTheme",
		"/home/unnar/sublime.tmtheme",
		"/home/unnar/sublime-theme/sublime.sublime-theme",
		"/home/unnar/.config/sublime-text-3/Packages/User/Preferences.sublime-settings",
		"/home/unnar/Desktop/base16-eighties.dark.tmTheme",
		"/home/unnar/.config/sublime-text-3/Packages/Default/Preferences.sublime-settings",
		"/home/unnar/.config/sublime-text-3/Packages/User/GitGutter.sublime-settings",
		"/home/unnar/.config/sublime-text-3/Packages/GitGutter/GitGutter.sublime-settings",
		"/home/unnar/catkin_ws/src/exx_wall_extraction/src/clouds/mesh.vtk",
		"/media/unnar/Downloads/transmission-postprocess-manual.sh",
		"/usr/share/applications/viewer.desktop",
		"/home/unnar/bash_aliases",
		"/home/unnar/.bashrc",
		"/home/unnar/.bashcr",
		"/home/unnar/catkin_ws/src/exx_wall_extraction/.git/config",
		"/home/unnar/catkin_ws/src/beginner_tutorials/src/talker.cpp",
		"/home/unnar/catkin_ws/src/beginner_tutorials/src/listener.cpp",
		"/home/unnar/catkin_ws/src/beginner_tutorials/msg/Num.msg",
		"/home/unnar/catkin_ws/src/beginner_tutorials/package.xml",
		"/home/unnar/catkin_ws/src/beginner_tutorials/CMakeLists.txt"
	],
	"find":
	{
		"height": 42.0
	},
	"find_in_files":
	{
		"height": 118.0,
		"where_history":
		[
			"/home/unnar/catkin_ws/src/rosOgre",
			"/home/unnar/catkin_ws/src/rosOgre/include"
		]
	},
	"find_state":
	{
		"case_sensitive": false,
		"find_history":
		[
			"RenderSystem_GL",
			"octree",
			"mResourcesCfg",
			"SVColorImportance_",
			"RGBA",
			"3",
			"CameraM",
			"mMov",
			"mMo",
			"it",
			"((*it",
			"*it",
			"points",
			"((*it)->",
			"(*it)",
			"cloud",
			"cloudPath",
			"std::string",
			"go(",
			"..",
			".zip",
			"../med",
			"sdk",
			"SDK",
			"go(",
			"setup",
			"setupResources",
			"mResourcesCfg",
			"cfg",
			"comment",
			"triangulation",
			"triangles_planes",
			"Ogre::Real ",
			"std::cout",
			"printSelectedPoints",
			"std::cout",
			"base",
			"a_",
			"a",
			"Points[0]",
			"pointIdxNKNSearch",
			"11",
			"99",
			" 2 ",
			"2 ",
			"12",
			"15",
			"87",
			"88",
			"[i",
			"i",
			"ind_loop",
			"(i+1)*(j+1)-1",
			"i*j",
			"ogreManual",
			"SdkTrays",
			"SdkTrays.zip",
			"PROJECT_BINARY_DIR",
			"CMAKE_MODULE_PATH",
			"/OGRE/",
			"CONCAVEHULL_H",
			"CONCAVEHULL",
			"indices",
			"PLANEEXTRACTION_H",
			"PLANEEXTRACTION",
			"PointNCloudT",
			"leaf_size",
			"Eigen",
			" \n",
			"pcl::PointXYZ",
			"pcl::Normal",
			"pcl::PointCloud<PointT>",
			"new pcl::PointCloud<PointT> ",
			" pcl::PointCloud<PointT>",
			"pcl::PointCloud<PointT> ",
			"pcl::PointCloud<PointT>",
			" ());",
			"pcl::PointCloud<PointT> ",
			"pcl::PointCloud<PointT>",
			"57",
			"folder",
			"gitg",
			"number",
			"functio",
			"dasfæadslfkæalsdkf",
			"PointCloudT",
			"cloud",
			"compressed_extracted_planes",
			"compressed_extracted_projected_planes",
			"(*planes)[i]",
			"pcl::PointXYZ",
			"at",
			"x0x1.at",
			".at",
			"at",
			"x0x1.at",
			".at",
			"last",
			"cross",
			"nextCheck",
			"current",
			"PointT",
			"next",
			"PointT next",
			"PointT ",
			"sor",
			"        //sor",
			"//",
			"sor",
			"        //sor",
			"//",
			"pcl::io"
		],
		"highlight": true,
		"in_selection": false,
		"preserve_case": false,
		"regex": false,
		"replace_history":
		[
		],
		"reverse": false,
		"show_context": true,
		"use_buffer2": true,
		"whole_word": false,
		"wrap": true
	},
	"groups":
	[
		{
			"selected": 1,
			"sheets":
			[
				{
					"buffer": 0,
					"file": "src/TutorialApplication.cpp",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 8925,
						"regions":
						{
						},
						"selection":
						[
							[
								5083,
								5083
							]
						],
						"settings":
						{
							"BracketHighlighterBusy": false,
							"bh_regions":
							[
								"bh_c_define",
								"bh_c_define_center",
								"bh_c_define_open",
								"bh_c_define_close",
								"bh_c_define_content",
								"bh_curly",
								"bh_curly_center",
								"bh_curly_open",
								"bh_curly_close",
								"bh_curly_content",
								"bh_angle",
								"bh_angle_center",
								"bh_angle_open",
								"bh_angle_close",
								"bh_angle_content",
								"bh_square",
								"bh_square_center",
								"bh_square_open",
								"bh_square_close",
								"bh_square_content",
								"bh_double_quote",
								"bh_double_quote_center",
								"bh_double_quote_open",
								"bh_double_quote_close",
								"bh_double_quote_content",
								"bh_default",
								"bh_default_center",
								"bh_default_open",
								"bh_default_close",
								"bh_default_content",
								"bh_tag",
								"bh_tag_center",
								"bh_tag_open",
								"bh_tag_close",
								"bh_tag_content",
								"bh_round",
								"bh_round_center",
								"bh_round_open",
								"bh_round_close",
								"bh_round_content",
								"bh_regex",
								"bh_regex_center",
								"bh_regex_open",
								"bh_regex_close",
								"bh_regex_content",
								"bh_unmatched",
								"bh_unmatched_center",
								"bh_unmatched_open",
								"bh_unmatched_close",
								"bh_unmatched_content",
								"bh_single_quote",
								"bh_single_quote_center",
								"bh_single_quote_open",
								"bh_single_quote_close",
								"bh_single_quote_content"
							],
							"syntax": "Packages/C++/C.tmLanguage",
							"tab_size": 4,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
						"translation.y": 2662.0,
						"zoom_level": 1.0
					},
					"stack_index": 2,
					"type": "text"
				},
				{
					"buffer": 1,
					"file": "include/TutorialApplication.h",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 1651,
						"regions":
						{
						},
						"selection":
						[
							[
								1305,
								1305
							]
						],
						"settings":
						{
							"BracketHighlighterBusy": false,
							"bh_regions":
							[
								"bh_c_define",
								"bh_c_define_center",
								"bh_c_define_open",
								"bh_c_define_close",
								"bh_c_define_content",
								"bh_curly",
								"bh_curly_center",
								"bh_curly_open",
								"bh_curly_close",
								"bh_curly_content",
								"bh_angle",
								"bh_angle_center",
								"bh_angle_open",
								"bh_angle_close",
								"bh_angle_content",
								"bh_square",
								"bh_square_center",
								"bh_square_open",
								"bh_square_close",
								"bh_square_content",
								"bh_double_quote",
								"bh_double_quote_center",
								"bh_double_quote_open",
								"bh_double_quote_close",
								"bh_double_quote_content",
								"bh_default",
								"bh_default_center",
								"bh_default_open",
								"bh_default_close",
								"bh_default_content",
								"bh_tag",
								"bh_tag_center",
								"bh_tag_open",
								"bh_tag_close",
								"bh_tag_content",
								"bh_round",
								"bh_round_center",
								"bh_round_open",
								"bh_round_close",
								"bh_round_content",
								"bh_regex",
								"bh_regex_center",
								"bh_regex_open",
								"bh_regex_close",
								"bh_regex_content",
								"bh_unmatched",
								"bh_unmatched_center",
								"bh_unmatched_open",
								"bh_unmatched_close",
								"bh_unmatched_content",
								"bh_single_quote",
								"bh_single_quote_center",
								"bh_single_quote_open",
								"bh_single_quote_close",
								"bh_single_quote_content"
							],
							"syntax": "Packages/C++/C.tmLanguage",
							"tab_size": 2,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
						"translation.y": 286.0,
						"zoom_level": 1.0
					},
					"stack_index": 0,
					"type": "text"
				},
				{
					"buffer": 2,
					"file": "include/BaseApplication.h",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 3229,
						"regions":
						{
						},
						"selection":
						[
							[
								1023,
								1023
							]
						],
						"settings":
						{
							"BracketHighlighterBusy": false,
							"bh_regions":
							[
								"bh_c_define",
								"bh_c_define_center",
								"bh_c_define_open",
								"bh_c_define_close",
								"bh_c_define_content",
								"bh_curly",
								"bh_curly_center",
								"bh_curly_open",
								"bh_curly_close",
								"bh_curly_content",
								"bh_angle",
								"bh_angle_center",
								"bh_angle_open",
								"bh_angle_close",
								"bh_angle_content",
								"bh_square",
								"bh_square_center",
								"bh_square_open",
								"bh_square_close",
								"bh_square_content",
								"bh_double_quote",
								"bh_double_quote_center",
								"bh_double_quote_open",
								"bh_double_quote_close",
								"bh_double_quote_content",
								"bh_default",
								"bh_default_center",
								"bh_default_open",
								"bh_default_close",
								"bh_default_content",
								"bh_tag",
								"bh_tag_center",
								"bh_tag_open",
								"bh_tag_close",
								"bh_tag_content",
								"bh_round",
								"bh_round_center",
								"bh_round_open",
								"bh_round_close",
								"bh_round_content",
								"bh_regex",
								"bh_regex_center",
								"bh_regex_open",
								"bh_regex_close",
								"bh_regex_content",
								"bh_unmatched",
								"bh_unmatched_center",
								"bh_unmatched_open",
								"bh_unmatched_close",
								"bh_unmatched_content",
								"bh_single_quote",
								"bh_single_quote_center",
								"bh_single_quote_open",
								"bh_single_quote_close",
								"bh_single_quote_content"
							],
							"syntax": "Packages/C++/C.tmLanguage",
							"tab_size": 4,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
						"translation.y": 330.0,
						"zoom_level": 1.0
					},
					"stack_index": 3,
					"type": "text"
				},
				{
					"buffer": 3,
					"file": "dist/bin/plugins.cfg",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 449,
						"regions":
						{
						},
						"selection":
						[
							[
								327,
								327
							]
						],
						"settings":
						{
							"BracketHighlighterBusy": false,
							"bh_regions":
							[
								"bh_regex",
								"bh_regex_center",
								"bh_regex_open",
								"bh_regex_close",
								"bh_regex_content",
								"bh_double_quote",
								"bh_double_quote_center",
								"bh_double_quote_open",
								"bh_double_quote_close",
								"bh_double_quote_content",
								"bh_square",
								"bh_square_center",
								"bh_square_open",
								"bh_square_close",
								"bh_square_content",
								"bh_angle",
								"bh_angle_center",
								"bh_angle_open",
								"bh_angle_close",
								"bh_angle_content",
								"bh_tag",
								"bh_tag_center",
								"bh_tag_open",
								"bh_tag_close",
								"bh_tag_content",
								"bh_curly",
								"bh_curly_center",
								"bh_curly_open",
								"bh_curly_close",
								"bh_curly_content",
								"bh_c_define",
								"bh_c_define_center",
								"bh_c_define_open",
								"bh_c_define_close",
								"bh_c_define_content",
								"bh_default",
								"bh_default_center",
								"bh_default_open",
								"bh_default_close",
								"bh_default_content",
								"bh_round",
								"bh_round_center",
								"bh_round_open",
								"bh_round_close",
								"bh_round_content",
								"bh_unmatched",
								"bh_unmatched_center",
								"bh_unmatched_open",
								"bh_unmatched_close",
								"bh_unmatched_content",
								"bh_single_quote",
								"bh_single_quote_center",
								"bh_single_quote_open",
								"bh_single_quote_close",
								"bh_single_quote_content"
							],
							"syntax": "Packages/Text/Plain text.tmLanguage"
						},
						"translation.x": 0.0,
						"translation.y": 0.0,
						"zoom_level": 1.0
					},
					"stack_index": 4,
					"type": "text"
				},
				{
					"buffer": 4,
					"file": "parameters/parameters.yaml",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 849,
						"regions":
						{
						},
						"selection":
						[
							[
								535,
								535
							]
						],
						"settings":
						{
							"BracketHighlighterBusy": false,
							"auto_name": "parameters.yaml",
							"bh_regions":
							[
								"bh_c_define",
								"bh_c_define_center",
								"bh_c_define_open",
								"bh_c_define_close",
								"bh_c_define_content",
								"bh_curly",
								"bh_curly_center",
								"bh_curly_open",
								"bh_curly_close",
								"bh_curly_content",
								"bh_angle",
								"bh_angle_center",
								"bh_angle_open",
								"bh_angle_close",
								"bh_angle_content",
								"bh_square",
								"bh_square_center",
								"bh_square_open",
								"bh_square_close",
								"bh_square_content",
								"bh_double_quote",
								"bh_double_quote_center",
								"bh_double_quote_open",
								"bh_double_quote_close",
								"bh_double_quote_content",
								"bh_default",
								"bh_default_center",
								"bh_default_open",
								"bh_default_close",
								"bh_default_content",
								"bh_tag",
								"bh_tag_center",
								"bh_tag_open",
								"bh_tag_close",
								"bh_tag_content",
								"bh_round",
								"bh_round_center",
								"bh_round_open",
								"bh_round_close",
								"bh_round_content",
								"bh_regex",
								"bh_regex_center",
								"bh_regex_open",
								"bh_regex_close",
								"bh_regex_content",
								"bh_unmatched",
								"bh_unmatched_center",
								"bh_unmatched_open",
								"bh_unmatched_close",
								"bh_unmatched_content",
								"bh_single_quote",
								"bh_single_quote_center",
								"bh_single_quote_open",
								"bh_single_quote_close",
								"bh_single_quote_content"
							],
							"syntax": "Packages/YAML/YAML.tmLanguage",
							"translate_tabs_to_spaces": true
						},
						"translation.x": 10.0,
						"translation.y": 0.0,
						"zoom_level": 1.0
					},
					"stack_index": 1,
					"type": "text"
				},
				{
					"buffer": 5,
					"file": "README.md",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 564,
						"regions":
						{
						},
						"selection":
						[
							[
								275,
								275
							]
						],
						"settings":
						{
							"BracketHighlighterBusy": false,
							"bh_regions":
							[
								"bh_single_quote",
								"bh_single_quote_center",
								"bh_single_quote_open",
								"bh_single_quote_close",
								"bh_single_quote_content",
								"bh_c_define",
								"bh_c_define_center",
								"bh_c_define_open",
								"bh_c_define_close",
								"bh_c_define_content",
								"bh_regex",
								"bh_regex_center",
								"bh_regex_open",
								"bh_regex_close",
								"bh_regex_content",
								"bh_default",
								"bh_default_center",
								"bh_default_open",
								"bh_default_close",
								"bh_default_content",
								"bh_square",
								"bh_square_center",
								"bh_square_open",
								"bh_square_close",
								"bh_square_content",
								"bh_curly",
								"bh_curly_center",
								"bh_curly_open",
								"bh_curly_close",
								"bh_curly_content",
								"bh_unmatched",
								"bh_unmatched_center",
								"bh_unmatched_open",
								"bh_unmatched_close",
								"bh_unmatched_content",
								"bh_round",
								"bh_round_center",
								"bh_round_open",
								"bh_round_close",
								"bh_round_content",
								"bh_angle",
								"bh_angle_center",
								"bh_angle_open",
								"bh_angle_close",
								"bh_angle_content",
								"bh_tag",
								"bh_tag_center",
								"bh_tag_open",
								"bh_tag_close",
								"bh_tag_content",
								"bh_double_quote",
								"bh_double_quote_center",
								"bh_double_quote_open",
								"bh_double_quote_close",
								"bh_double_quote_content"
							],
							"syntax": "Packages/Markdown/Markdown.tmLanguage"
						},
						"translation.x": 0.0,
						"translation.y": 0.0,
						"zoom_level": 1.0
					},
					"stack_index": 6,
					"type": "text"
				},
				{
					"buffer": 6,
					"file": "/usr/include/OGRE/Samples/Common/include/SdkTrays.h",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 103737,
						"regions":
						{
						},
						"selection":
						[
							[
								0,
								0
							]
						],
						"settings":
						{
							"BracketHighlighterBusy": false,
							"bh_regions":
							[
								"bh_single_quote",
								"bh_single_quote_center",
								"bh_single_quote_open",
								"bh_single_quote_close",
								"bh_single_quote_content",
								"bh_c_define",
								"bh_c_define_center",
								"bh_c_define_open",
								"bh_c_define_close",
								"bh_c_define_content",
								"bh_regex",
								"bh_regex_center",
								"bh_regex_open",
								"bh_regex_close",
								"bh_regex_content",
								"bh_default",
								"bh_default_center",
								"bh_default_open",
								"bh_default_close",
								"bh_default_content",
								"bh_square",
								"bh_square_center",
								"bh_square_open",
								"bh_square_close",
								"bh_square_content",
								"bh_curly",
								"bh_curly_center",
								"bh_curly_open",
								"bh_curly_close",
								"bh_curly_content",
								"bh_unmatched",
								"bh_unmatched_center",
								"bh_unmatched_open",
								"bh_unmatched_close",
								"bh_unmatched_content",
								"bh_round",
								"bh_round_center",
								"bh_round_open",
								"bh_round_close",
								"bh_round_content",
								"bh_angle",
								"bh_angle_center",
								"bh_angle_open",
								"bh_angle_close",
								"bh_angle_content",
								"bh_tag",
								"bh_tag_center",
								"bh_tag_open",
								"bh_tag_close",
								"bh_tag_content",
								"bh_double_quote",
								"bh_double_quote_center",
								"bh_double_quote_open",
								"bh_double_quote_close",
								"bh_double_quote_content"
							],
							"syntax": "Packages/C++/C.tmLanguage",
							"translate_tabs_to_spaces": false
						},
						"translation.x": 0.0,
						"translation.y": 396.0,
						"zoom_level": 1.0
					},
					"stack_index": 5,
					"type": "text"
				}
			]
		}
	],
	"incremental_find":
	{
		"height": 42.0
	},
	"input":
	{
		"height": 33.0
	},
	"layout":
	{
		"cells":
		[
			[
				0,
				0,
				1,
				1
			]
		],
		"cols":
		[
			0.0,
			1.0
		],
		"rows":
		[
			0.0,
			1.0
		]
	},
	"menu_visible": true,
	"output.exec":
	{
		"height": 54.0
	},
	"output.find_results":
	{
		"height": 0.0
	},
	"output.git":
	{
		"height": 74.0
	},
	"pinned_build_system": "",
	"project": "rosOgre.sublime-project",
	"replace":
	{
		"height": 56.0
	},
	"save_all_on_build": true,
	"select_file":
	{
		"height": 0.0,
		"last_filter": "",
		"selected_items":
		[
		],
		"width": 0.0
	},
	"select_project":
	{
		"height": 500.0,
		"last_filter": "",
		"selected_items":
		[
			[
				"",
				"~/catkin_ws/src/exx-compression/exx-compression.sublime-project"
			]
		],
		"width": 380.0
	},
	"select_symbol":
	{
		"height": 389.0,
		"last_filter": "",
		"selected_items":
		[
		],
		"width": 400.0
	},
	"selected_group": 0,
	"settings":
	{
	},
	"show_minimap": true,
	"show_open_files": false,
	"show_tabs": true,
	"side_bar_visible": true,
	"side_bar_width": 206.0,
	"status_bar_visible": true,
	"template_settings":
	{
	}
}
